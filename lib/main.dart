import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

// import 'package:google_fonts/google_fonts.dart'; // --- FIX: Removed google_fonts, we are bundling fonts locally
import 'dart:developer'; // Import for debugPrint
import 'package:intl/intl.dart'; // For formatting timestamps
import 'dart:math'; // For random animation values
import 'dart:ui'; // For ImageFilter.blur
import 'dart:async'; // --- FIX: Added for StreamSubscription (vibration & pairing requests)
import 'package:vibration/vibration.dart'; // --- FIX: Added for vibration package

// Import Firebase related packages
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'firebase_options.dart'; // This file is generated by `flutterfire configure`

// --- ⚠️ IMAGE PICKER FIX: Import Storage and Image Picker ---
import 'package:firebase_storage/firebase_storage.dart';
import 'package:image_picker/image_picker.dart';
import 'dart:io'; // For File type

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const HTHApp());
}

// --- App Theme and Constants ---
class AppColors {
  static const Color primaryBackground = Color(0xFF1C1C1E); // Dark Grey
  static const Color cardBackground = Color(0xFF2C2C2E); // Slightly Lighter Dark Grey
  static const Color accentOrange = Color(0xFFFF5200); // Vibrant Orange
  static const Color textPrimary = Colors.white;
  static final Color textSecondary = Colors.white.withOpacity(0.7); // Lighter white for secondary text
  static const Color iconColor = Colors.white;
  static const Color errorRed = Colors.redAccent;
  static const Color streakFlame = Colors.orangeAccent; // Color for streak icon
  static const Color bottomNavBackground = Colors.black; // Slightly transparent black

  // --- ⚠️ CHAT UI FIX: "Me" is Orange, "Partner" is Grey ---
  static const Color chatBubbleMe = Color(0xFFFF5200);
  static const Color chatBubblePartner = Color(0xFF2C2C2E);
}

class AppTextStyles {
  // --- FIX: Use the bundled font family name 'Inter'
  static const String _fontFamily = 'Inter';

  static final TextStyle headline1 = const TextStyle(
      fontFamily: _fontFamily,
      fontSize: 32, fontWeight: FontWeight.bold, color: AppColors.textPrimary);
  static final TextStyle headline2 = const TextStyle(
      fontFamily: _fontFamily,
      fontSize: 24, fontWeight: FontWeight.bold, color: AppColors.textPrimary);
  static final TextStyle bodyText = const TextStyle(
      fontFamily: _fontFamily,
      fontSize: 16, color: AppColors.textPrimary);
  static final TextStyle buttonText = const TextStyle(
      fontFamily: _fontFamily,
      fontSize: 18, fontWeight: FontWeight.bold, color: AppColors.textPrimary);
  static final TextStyle smallButtonText = const TextStyle(
      fontFamily: _fontFamily,
      fontSize: 14, color: AppColors.textPrimary);
  static final TextStyle linkText = const TextStyle(
      fontFamily: _fontFamily,
      fontSize: 14, color: AppColors.accentOrange, fontWeight: FontWeight.w600);

  // --- FIX: Added style for history tags ---
  static final TextStyle historyTagStyle = TextStyle(
      fontFamily: _fontFamily,
      fontSize: 10, fontWeight: FontWeight.bold, color: AppColors.textSecondary.withOpacity(0.8));

  // --- FIX: Added smaller text style for pairing code if needed ---
  static final TextStyle pairingCodeStyle = const TextStyle(
      fontFamily: _fontFamily,
      fontSize: 40, fontWeight: FontWeight.bold, letterSpacing: 8, color: AppColors.textPrimary);

  // --- CHAT BUBBLE TEXT STYLES ---
  static final TextStyle chatBubbleMessage = const TextStyle(
      fontFamily: _fontFamily,
      fontSize: 16, color: AppColors.textPrimary, height: 1.4);
  static final TextStyle chatBubbleTimestamp = TextStyle(
      fontFamily: _fontFamily,
      fontSize: 12, color: AppColors.textSecondary.withAlpha(180)); // 0.7 opacity
  static final TextStyle chatBubbleName = const TextStyle(
      fontFamily: _fontFamily,
      fontSize: 14, fontWeight: FontWeight.w600, color: AppColors.accentOrange);
}

// --- Entry Point ---
class HTHApp extends StatelessWidget {
  const HTHApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Heart to Heart',
      theme: ThemeData(
        brightness: Brightness.dark,
        primaryColor: AppColors.accentOrange,
        scaffoldBackgroundColor: AppColors.primaryBackground,
        // --- FIX: Use the bundled 'Inter' font
        textTheme: Theme.of(context).textTheme.apply(
          bodyColor: AppColors.textPrimary,
          displayColor: AppColors.textPrimary,
          fontFamily: 'Inter',
        ),
        appBarTheme: const AppBarTheme(
          backgroundColor: AppColors.primaryBackground,
          foregroundColor: AppColors.textPrimary,
          elevation: 0,
          systemOverlayStyle: SystemUiOverlayStyle.light,
        ),
        buttonTheme: const ButtonThemeData(
          buttonColor: AppColors.accentOrange,
          textTheme: ButtonTextTheme.primary,
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: AppColors.accentOrange,
            foregroundColor: AppColors.textPrimary,
            minimumSize: const Size(double.infinity, 50),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
            ),
            textStyle: AppTextStyles.buttonText,
          ),
        ),
        // --- FIX: Added OutlinedButton theme ---
        outlinedButtonTheme: OutlinedButtonThemeData(
            style: OutlinedButton.styleFrom(
              foregroundColor: AppColors.textSecondary,
              side: BorderSide(color: AppColors.textSecondary.withOpacity(0.5)),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
              textStyle: AppTextStyles.buttonText.copyWith(fontWeight: FontWeight.w600),
            )
        ),
        textButtonTheme: TextButtonThemeData(
          style: TextButton.styleFrom(
            foregroundColor: AppColors.accentOrange,
            textStyle: AppTextStyles.linkText,
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: AppColors.cardBackground,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide.none,
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide.none,
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: AppColors.accentOrange, width: 2),
          ),
          hintStyle: AppTextStyles.bodyText.copyWith(color: AppColors.textSecondary.withAlpha(128)),
        ),
        // --- FIX: Corrected object type from CardTheme to CardThemeData ---
        cardTheme: CardThemeData(
          elevation: 0,
          color: AppColors.cardBackground, // Default card color
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          margin: const EdgeInsets.symmetric(vertical: 4.0), // Default margin for cards
        ),
        dividerColor: Colors.white.withAlpha(26),
        tabBarTheme:  TabBarThemeData(
          labelColor: AppColors.accentOrange,
          unselectedLabelColor: AppColors.textSecondary,
          indicatorSize: TabBarIndicatorSize.label,
          indicator: UnderlineTabIndicator(
            borderSide: BorderSide(color: AppColors.accentOrange, width: 3.0),
          ),
        ),
        textSelectionTheme: const TextSelectionThemeData(
          cursorColor: AppColors.accentOrange,
          selectionColor: AppColors.accentOrange,
          selectionHandleColor: AppColors.accentOrange,
        ),
        // Define BottomNavigationBar theme for consistency
        bottomNavigationBarTheme: BottomNavigationBarThemeData(
          // --- FIX: Set background to transparent. The blur/tint is handled in DashboardScreen.
          backgroundColor: Colors.transparent,
          selectedItemColor: AppColors.accentOrange,
          unselectedItemColor: AppColors.textSecondary.withOpacity(0.7),
          selectedLabelStyle: AppTextStyles.smallButtonText.copyWith(fontSize: 12, fontFamily: 'Inter'),
          unselectedLabelStyle: AppTextStyles.smallButtonText.copyWith(fontSize: 12, fontFamily: 'Inter'),
          type: BottomNavigationBarType.fixed, // Ensure all items are visible
          elevation: 0, // Remove default elevation
        ),
      ),
      debugShowCheckedModeBanner: false,
      home: StreamBuilder<User?>(
        stream: FirebaseAuth.instance.authStateChanges(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Scaffold(
                body: Center(child: CircularProgressIndicator()));
          }
          if (snapshot.hasData) {
            // User is logged in, check for pairing status & display name
            return const PairingCheckerScreen();
          }
          return const AuthScreen(); // User is not logged in
        },
      ),
      // Define routes for navigation
      routes: {
        '/auth': (context) => const AuthScreen(),
        '/checker': (context) => const PairingCheckerScreen(),
        // --- FIX: Add route for Dashboard for explicit navigation ---
        '/dashboard': (context) {
          // Attempt to get partnerId from arguments or handle error
          final args = ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
          final partnerId = args?['partnerId'] as String?;
          if (partnerId == null) {
            // Handle error: Maybe navigate back or show error screen
            debugPrint("Error: Navigated to dashboard without partnerId!");
            WidgetsBinding.instance.addPostFrameCallback((_) {
              // --- ⚠️ MOUNTED CHECK FIX ---
              if (context.mounted && Navigator.canPop(context)) {
                Navigator.pop(context);
              } else {
                // If cannot pop, maybe go back to auth as a fallback
                FirebaseAuthService().signOut();
              }
            });
            return const Scaffold(body: Center(child: Text("Error: Missing partner info.")));
          }
          return DashboardScreen(partnerId: partnerId);
        },
      },
    );
  }
}

// --- Utility Widgets ---

// Responsive Centered Layout
class ResponsiveCenter extends StatelessWidget {
  final Widget child;
  final double maxWidth;
  const ResponsiveCenter({
    super.key,
    required this.child,
    this.maxWidth = 600,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: ConstrainedBox(
        constraints: BoxConstraints(maxWidth: maxWidth),
        child: child,
      ),
    );
  }
}

class GradientBackground extends StatelessWidget {
  final Widget child;
  const GradientBackground({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          colors: [
            Color(0xFF1C1C1E),
            Color(0xFF000000), // Slightly darker at the bottom for depth
          ],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
      ),
      child: child,
    );
  }
}

// --- Custom Confirmation Dialog ---
Future<bool> showConfirmationDialog(
    BuildContext context,
    {required String title,
      required String content,
      String confirmText = "Confirm",
      bool isDestructive = false
    }) async {
  return await showDialog<bool>(
    context: context,
    builder: (context) {
      return AlertDialog(
        backgroundColor: AppColors.cardBackground,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Text(title, style: AppTextStyles.headline2.copyWith(fontSize: 20)),
        content: Text(content, style: AppTextStyles.bodyText),
        // --- FIX: Use Row with padding for better button alignment ---
        actionsPadding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
        actions: [
          Row(
            children: [
              Expanded(
                child: OutlinedButton( // Cancel is outlined
                  onPressed: () => Navigator.of(context).pop(false),
                  child: const Text('Cancel'),
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: ElevatedButton( // Confirm is filled
                  style: ElevatedButton.styleFrom(
                    backgroundColor: isDestructive ? AppColors.errorRed : AppColors.accentOrange,
                    minimumSize: const Size(double.infinity, 44), // Ensure consistent height
                  ),
                  onPressed: () => Navigator.of(context).pop(true),
                  child: Text(confirmText),
                ),
              ),
            ],
          ),
        ],
      );
    },
  ) ?? false; // Return false if dialog is dismissed
}

// --- Firebase Service (Authentication) ---
class FirebaseAuthService {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final GoogleSignIn _googleSignIn = GoogleSignIn(
    clientId: kIsWeb
        ? 'YOUR_WEB_CLIENT_ID_HERE' // TODO: PASTE YOUR OAuth 2.0 WEB CLIENT ID HERE
        : null,
  );
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  User? get currentUser => _auth.currentUser;

  // Google Sign-In
  Future<User?> signInWithGoogle() async {
    // CRITICAL FIX: Check if the placeholder is still being used
    if (kIsWeb && _googleSignIn.clientId == 'YOUR_WEB_CLIENT_ID_HERE') {
      debugPrint("="*50);
      debugPrint("ERROR: Google Sign-In failed on WEB.");
      debugPrint("You MUST replace 'YOUR_WEB_CLIENT_ID_HERE' in main.dart");
      debugPrint("with your actual Firebase Web Client ID.");
      debugPrint("="*50);
      return null;
    }

    try {
      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
      if (googleUser == null) return null; // User cancelled

      final GoogleSignInAuthentication googleAuth =
      await googleUser.authentication;
      final AuthCredential credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken,
        idToken: googleAuth.idToken,
      );

      UserCredential userCredential = await _auth.signInWithCredential(credential);
      await _createUserDocument(userCredential.user!); // Ensure user doc exists
      return userCredential.user;
    } catch (e) {
      debugPrint("Google Sign-In Error: $e");
      debugPrint("=" * 50);
      debugPrint("If this is 'ApiException: 10' on Android, ensure your SHA-1 fingerprint is");
      debugPrint("correctly added to your Firebase project settings for the Android app.");
      debugPrint("Run './gradlew signingReport' in the 'android' folder to find your SHA-1 key.");
      debugPrint("=" * 50);
      return null;
    }
  }

  // Email/Password Sign-In
  Future<User?> signInWithEmail(String email, String password) async {
    try {
      UserCredential userCredential = await _auth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      return userCredential.user;
    } catch (e) {
      debugPrint("Email Sign-In Error: $e");
      return null;
    }
  }

  // Email/Password Sign-Up
  Future<User?> signUpWithEmail(String email, String password) async {
    try {
      UserCredential userCredential = await _auth.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );
      await _createUserDocument(userCredential.user!); // Create user doc
      return userCredential.user;
    } catch (e) {
      debugPrint("Email Sign-Up Error: $e");
      return null;
    }
  }

  // Ensure user document exists in Firestore or updates photoURL/streak defaults
  Future<void> _createUserDocument(User user) async {
    final userDocRef = _firestore.collection('users').doc(user.uid);
    final docSnapshot = await userDocRef.get();

    final data = {
      'uid': user.uid,
      'email': user.email,
      'photoURL': user.photoURL, // Keep photoURL updated
      'displayName': user.displayName ?? user.email?.split('@')[0], // Ensure display name is set
      'createdAt': FieldValue.serverTimestamp(),
      'lastSentTimestamp': null,
      'currentStreak': 0,
      'partnerId': null,
      // Add new presence and daily fields on creation
      'isOnline': false,
      'lastSeen': FieldValue.serverTimestamp(),
      'myMood': '',
      'myActivity': '',
      'thinkingOfYou': '',
      'pairedAt': null, // --- ⚠️ NEW: Add pairedAt field ---
    };

    // Use set with merge: true to create or update safely
    await userDocRef.set(data, SetOptions(merge: true));

  }

  // Sign Out
  Future<void> signOut() async {
    // Set user offline before signing out
    final uid = _auth.currentUser?.uid;
    if (uid != null) {
      await FirestoreService().updateUserPresence(false);
    }
    await _googleSignIn.signOut();
    await _auth.signOut();
  }
}

// --- ⚠️ NEW: Firebase Storage Service ---
class FirebaseStorageService {
  final FirebaseStorage _storage = FirebaseStorage.instance;
  final String? _currentUserUid = FirebaseAuth.instance.currentUser?.uid;

  Future<String?> uploadProfilePicture(XFile imageFile) async {
    if (_currentUserUid == null) return null;

    try {
      // Create a unique file name
      final String fileName = '${DateTime.now().millisecondsSinceEpoch}.jpg';
      final Reference storageRef = _storage
          .ref()
          .child('profile_pictures')
          .child(_currentUserUid!)
          .child(fileName);

      // Upload the file
      UploadTask uploadTask;
      if (kIsWeb) {
        // For web, upload using bytes
        uploadTask = storageRef.putData(await imageFile.readAsBytes());
      } else {
        // For mobile, upload using the file path
        uploadTask = storageRef.putFile(File(imageFile.path));
      }

      final TaskSnapshot snapshot = await uploadTask;

      // Get the download URL
      final String downloadUrl = await snapshot.ref.getDownloadURL();

      // Update the user's photoURL in Firestore
      await FirebaseFirestore.instance
          .collection('users')
          .doc(_currentUserUid)
          .update({'photoURL': downloadUrl});

      return downloadUrl;
    } catch (e) {
      debugPrint("Error uploading profile picture: $e");
      return null;
    }
  }
}


// --- Firestore Service (Data) ---
enum PairingStatus {
  idle, // Not trying to pair
  requestSent, // Code entered, waiting for partner
  requestReceived, // Partner entered our code
  accepted, // Partner accepted
  declined, // Partner declined
  failedAlreadyPaired, // One user was already paired
  failedError, // General Firestore error
}

class FirestoreService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  String? get _currentUserUid => FirebaseAuth.instance.currentUser?.uid;
  String? get _currentUserDisplayName => FirebaseAuth.instance.currentUser?.displayName ?? FirebaseAuth.instance.currentUser?.email?.split('@')[0];
  String? get _currentUserEmail => FirebaseAuth.instance.currentUser?.email;

  // Helper to get current user document snapshot
  Future<DocumentSnapshot<Map<String, dynamic>>> _getCurrentUserDoc() async {
    if (_currentUserUid == null) throw Exception("User not logged in");
    return _firestore.collection('users').doc(_currentUserUid).get();
  }


  // Get a stream of the current user's document
  Stream<DocumentSnapshot<Map<String, dynamic>>> get userStream {
    if (_currentUserUid == null) return Stream.error("User not logged in");
    return _firestore.collection('users').doc(_currentUserUid).snapshots();
  }

  // Get a stream of the partner's document
  Stream<DocumentSnapshot<Map<String, dynamic>>> getPartnerStream(String partnerId) {
    if (partnerId.isEmpty) return Stream.error("Invalid Partner ID");
    return _firestore.collection('users').doc(partnerId).snapshots();
  }

  // --- NEW: Presence Update Method ---
  Future<void> updateUserPresence(bool isOnline) async {
    if (_currentUserUid == null) return;
    try {
      await _firestore.collection('users').doc(_currentUserUid).update({
        'isOnline': isOnline,
        'lastSeen': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      // This will fail if rules aren't updated, log it quietly
      debugPrint("Error updating presence: $e");
    }
  }


  // Generates a unique 6-digit pairing code, returns null if already paired
  Future<String?> generatePairingCode(String userId) async {
    // --- ⚠️ RE-PAIRING BUG FIX: Re-fetch doc to ensure we have latest data ---
    final userDoc = await _firestore.collection('users').doc(userId).get();
    if (userDoc.exists && userDoc.data()?['partnerId'] != null) {
      debugPrint("Cannot generate code: User already paired.");
      return null;
    }

    String code = (DateTime.now().microsecondsSinceEpoch % 1000000).toString().padLeft(6, '0');
    await _firestore.collection('pairing_codes').doc(code).set({
      'creatorId': userId,
      'createdAt': FieldValue.serverTimestamp(),
      'isActive': true,
    });
    return code;
  }

  // --- NEW: Send Pairing Request ---
  // Attempts to send a pairing request using a code
  Future<String?> sendPairingRequest(String code, String currentUserId) async {
    // Check if the current user is already paired
    final currentUserDoc = await _getCurrentUserDoc();
    if (currentUserDoc.exists && currentUserDoc.data()?['partnerId'] != null) {
      debugPrint("Cannot send request: Current user already paired.");
      return "failed_already_paired"; // Special return value for UI
    }

    final codeDocRef = _firestore.collection('pairing_codes').doc(code);
    final codeSnapshot = await codeDocRef.get();

    if (!codeSnapshot.exists || !(codeSnapshot.data()?['isActive'] ?? false)) {
      debugPrint("Cannot send request: Invalid or inactive code.");
      return null; // Indicates invalid code
    }

    final codeOwnerId = codeSnapshot.data()?['creatorId'];
    if (codeOwnerId == null || codeOwnerId == currentUserId) {
      debugPrint("Cannot send request: Invalid creator or self-pairing.");
      return null; // Invalid creator
    }

    // Check if the code owner is already paired
    final codeOwnerDoc = await _firestore.collection('users').doc(codeOwnerId).get();
    if (codeOwnerDoc.exists && codeOwnerDoc.data()?['partnerId'] != null) {
      debugPrint("Cannot send request: Code owner ($codeOwnerId) already paired.");
      // Deactivate the code as it can't be used
      await codeDocRef.update({'isActive': false, 'reason': 'owner_already_paired'});
      return "failed_already_paired"; // Special return value for UI
    }

    // Create the pairing request document
    try {
      final requestRef = await _firestore.collection('pairing_requests').add({
        'requesterId': currentUserId,
        'codeOwnerId': codeOwnerId,
        'requesterName': _currentUserDisplayName ?? _currentUserEmail ?? 'Unknown User', // Use display name or email
        'status': 'pending', // Initial status
        'createdAt': FieldValue.serverTimestamp(),
        'pairingCode': code, // Store the code used
      });
      // Deactivate the pairing code immediately after creating the request
      await codeDocRef.update({'isActive': false, 'reason': 'request_created'});
      debugPrint("Pairing request sent successfully, doc ID: ${requestRef.id}");
      return requestRef.id; // Return the ID of the request document
    } catch (e) {
      debugPrint("Error creating pairing request: $e");
      return null; // Indicate error
    }
  }

  // --- NEW: Stream for incoming pairing requests ---
  Stream<QuerySnapshot<Map<String, dynamic>>> getIncomingPairingRequests() {
    if (_currentUserUid == null) return Stream.error("User not logged in");
    // Query requires a composite index: codeOwnerId (asc), status (asc), createdAt (desc)
    return _firestore
        .collection('pairing_requests')
        .where('codeOwnerId', isEqualTo: _currentUserUid)
        .where('status', isEqualTo: 'pending')
        .orderBy('createdAt', descending: true)
        .limit(1) // Usually only one active request expected
        .snapshots();
  }

  // --- NEW: Stream for the status of an outgoing pairing request ---
  Stream<DocumentSnapshot<Map<String, dynamic>>> getOutgoingPairingRequestStatus(String requestId) {
    if (requestId.isEmpty) return Stream.error("Invalid request ID");
    return _firestore.collection('pairing_requests').doc(requestId).snapshots();
  }

  // --- NEW: Accept Pairing Request ---
  Future<bool> acceptPairingRequest(String requestId, String requesterId) async {
    if (_currentUserUid == null) return false;
    final String codeOwnerId = _currentUserUid!;
    final requestDocRef = _firestore.collection('pairing_requests').doc(requestId);

    try {
      return await _firestore.runTransaction<bool>((transaction) async {
        // Re-fetch docs within transaction
        final freshRequestDoc = await transaction.get(requestDocRef);
        final freshCodeOwnerDoc = await transaction.get(_firestore.collection('users').doc(codeOwnerId));
        final freshRequesterDoc = await transaction.get(_firestore.collection('users').doc(requesterId));

        // Validate request status and user pairing status
        if (!freshRequestDoc.exists || freshRequestDoc.data()?['status'] != 'pending') {
          debugPrint("Transaction failed: Request is not pending.");
          return false;
        }
        if (freshCodeOwnerDoc.data()?['partnerId'] != null || freshRequesterDoc.data()?['partnerId'] != null) {
          debugPrint("Transaction failed: One user is already paired.");
          transaction.update(requestDocRef, {'status': 'failed_already_paired', 'respondedAt': FieldValue.serverTimestamp()});
          return false;
        }

        // --- ⚠️ NEW: Store the pairing timestamp ---
        final now = FieldValue.serverTimestamp();

        // Perform the pairing updates
        transaction.update(_firestore.collection('users').doc(codeOwnerId), {'partnerId': requesterId, 'pairedAt': now});
        transaction.update(_firestore.collection('users').doc(requesterId), {'partnerId': codeOwnerId, 'pairedAt': now});
        transaction.update(requestDocRef, {'status': 'accepted', 'respondedAt': now});

        debugPrint("Pairing request accepted successfully.");
        return true; // Indicate success
      });
    } catch (error) {
      debugPrint("Accept pairing transaction failed: $error");
      // Attempt to mark request as errored if transaction fails
      try { await requestDocRef.update({'status': 'failed_error', 'error': error.toString()}); } catch (_) {}
      return false; // Indicate failure
    }
  }

  // --- NEW: Decline Pairing Request ---
  Future<bool> declinePairingRequest(String requestId) async {
    final requestDocRef = _firestore.collection('pairing_requests').doc(requestId);
    try {
      await requestDocRef.update({'status': 'declined', 'respondedAt': FieldValue.serverTimestamp()});
      debugPrint("Pairing request declined.");
      return true;
    } catch (e) {
      debugPrint("Error declining pairing request: $e");
      return false;
    }
  }

  // Update the user's display name
  Future<void> updateDisplayName(String newName) async {
    if (_currentUserUid == null) return;
    await _firestore.collection('users').doc(_currentUserUid).update({
      'displayName': newName,
    });
  }

  // Update user profile details
  Future<void> updateUserProfile(Map<String, String> profileData) async {
    if (_currentUserUid == null) return;
    final Map<String, dynamic> dataToUpdate = {};
    profileData.forEach((key, value) {
      // Allow empty strings to be saved, to clear a field
      dataToUpdate[key] = value;
    });

    if (dataToUpdate.isNotEmpty) {
      await _firestore.collection('users').doc(_currentUserUid).update(dataToUpdate);
    }
  }


  // Unpair from partner
  Future<void> unpair(String partnerId) async {
    if (_currentUserUid == null || partnerId.isEmpty) return;
    await _firestore.runTransaction((transaction) async {
      // --- ⚠️ NEW: Reset pairedAt timestamp on unpair ---
      transaction.update(_firestore.collection('users').doc(_currentUserUid), {'partnerId': null, 'pairedAt': null});
      transaction.update(_firestore.collection('users').doc(partnerId), {'partnerId': null, 'pairedAt': null});
    }).catchError((error) {
      debugPrint("Unpairing transaction failed: $error");
      throw error;
    });
  }

  // --- Notification & Streak System ---
  Future<void> sendNotification(String partnerId, String message, String emoji) async {
    debugPrint("Sending notification..."); // --- DEBUG LOG ---
    if (_currentUserUid == null || partnerId.isEmpty) return;
    final now = Timestamp.now();
    final notifData = {
      'message': message, 'emoji': emoji, 'senderId': _currentUserUid, 'timestamp': now,
    };
    final batch = _firestore.batch();
    batch.set(_firestore.collection('users').doc(partnerId).collection('notifications').doc(), notifData);
    batch.set(_firestore.collection('users').doc(_currentUserUid).collection('notifications').doc(), notifData);

    final userRef = _firestore.collection('users').doc(_currentUserUid);
    final userDoc = await userRef.get();
    if (!userDoc.exists) return;
    final userData = userDoc.data();
    final lastSent = userData?['lastSentTimestamp'] as Timestamp?;
    final currentStreak = userData?['currentStreak'] as int? ?? 0;
    int newStreak = _calculateNewStreak(lastSent, currentStreak);
    batch.update(userRef, {'lastSentTimestamp': now, 'currentStreak': newStreak});
    await batch.commit();
    debugPrint("Notification sent."); // --- DEBUG LOG ---
  }

  int _calculateNewStreak(Timestamp? lastSent, int currentStreak) {
    int newStreak = 0;
    final today = DateTime.now();
    final todayStartUtc = DateTime.utc(today.year, today.month, today.day);
    if (lastSent != null) {
      final lastSentDate = lastSent.toDate();
      final lastSentStartUtc = DateTime.utc(lastSentDate.year, lastSentDate.month, lastSentDate.day);
      final difference = todayStartUtc.difference(lastSentStartUtc).inDays;
      if (difference == 1) newStreak = currentStreak + 1;
      else if (difference == 0) newStreak = currentStreak;
      else newStreak = 1;
    } else newStreak = 1;
    return newStreak;
  }

  Stream<QuerySnapshot<Map<String, dynamic>>> getNotificationsStream() {
    if (_currentUserUid == null) return Stream.error("User not logged in");
    return _firestore.collection('users').doc(_currentUserUid).collection('notifications')
        .orderBy('timestamp', descending: true).limit(50).snapshots(); // Increased limit
  }
}
// --- End FIX ---


// --- Screen 0: Initial checker after login ---
class PairingCheckerScreen extends StatefulWidget {
  const PairingCheckerScreen({super.key});
  @override State<PairingCheckerScreen> createState() => _PairingCheckerScreenState();
}
class _PairingCheckerScreenState extends State<PairingCheckerScreen> {
  final FirestoreService _firestoreService = FirestoreService();
  String? _lastNavigatedRoute; // Track last navigation target

  @override Widget build(BuildContext context) {
    return StreamBuilder<DocumentSnapshot<Map<String, dynamic>>>(
      stream: _firestoreService.userStream,
      builder: (context, snapshot) {
        // --- Loading State ---
        if (snapshot.connectionState == ConnectionState.waiting && !snapshot.hasData) { // Only show initial load
          debugPrint("Pairing Check State: Waiting for initial user data...");
          return const Scaffold(body: Center( child: CircularProgressIndicator(color: AppColors.accentOrange), ));
        }

        // --- Error State ---
        if (snapshot.hasError) {
          debugPrint("Pairing Check Stream Error: ${snapshot.error}");
          // Attempt signout on error to reset state
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (mounted) { // Check if still mounted
              FirebaseAuthService().signOut();
              // --- ⚠️ MOUNTED CHECK FIX ---
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Error loading data. Logging out.'), backgroundColor: AppColors.errorRed)
                );
              }
            }
          });
          // Show loading while signout happens
          return const Scaffold(body: Center( child: CircularProgressIndicator(color: AppColors.errorRed), ));
        }

        // --- No Data / User Doc Deleted State ---
        if (!snapshot.hasData || !snapshot.data!.exists) {
          debugPrint("Pairing Check State: User document not found. Waiting or potential issue...");
          return const Scaffold(body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ CircularProgressIndicator(color: AppColors.accentOrange), SizedBox(height: 16), Text('Checking account...'), ], ), ), );
        }

        // --- Data Exists - Determine Target Screen ---
        final userData = snapshot.data!.data()!;
        final partnerId = userData['partnerId'] as String?;
        final displayName = userData['displayName'] as String?;
        final currentUserEmail = FirebaseAuth.instance.currentUser?.email;
        final isDefaultName = displayName == null || displayName.isEmpty || (currentUserEmail != null && displayName.contains(currentUserEmail.split('@')[0]));
        final isGoogleUser = FirebaseAuth.instance.currentUser?.providerData.any((p) => p.providerId == GoogleAuthProvider.PROVIDER_ID) ?? false;
        final hasName = !isDefaultName || isGoogleUser;

        debugPrint("Pairing Check State: partnerId=$partnerId, displayName=$displayName, hasName=$hasName");


        // --- Schedule Navigation After Build ---
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (!mounted) {
            debugPrint("[Nav Callback] Widget not mounted. Skipping navigation.");
            return;
          }

          String targetRouteName;
          WidgetBuilder? targetRouteBuilder;
          Object? navigationArguments;

          if (partnerId != null) { // User is Paired
            if (hasName) { // Paired and has name -> Dashboard
              targetRouteName = '/dashboard';
              navigationArguments = {'partnerId': partnerId};
            } else { // Paired but needs name -> Set Display Name Screen
              targetRouteName = 'SetDisplayNameScreen';
              targetRouteBuilder = (_) => const SetDisplayNameScreen();
            }
          } else { // User is Not Paired -> Pairing Screen
            targetRouteName = 'PairingScreen';
            targetRouteBuilder = (_) => const PairingScreen();
          }

          final currentRoute = ModalRoute.of(context);
          final currentRouteName = currentRoute?.settings.name;
          final isDialogShowing = currentRoute is PopupRoute;

          debugPrint("[Nav Callback] Current=$currentRouteName, Target=$targetRouteName, Dialog=$isDialogShowing, LastNav=$_lastNavigatedRoute");

          if (isDialogShowing) {
            debugPrint("[Nav Callback] Dialog showing, skipping navigation.");
            return;
          }

          // Check if navigation is needed
          bool needsNavigation = false;
          if (targetRouteName == '/dashboard' && currentRouteName != '/dashboard') {
            needsNavigation = true;
          } else if (targetRouteName == 'SetDisplayNameScreen' && currentRouteName != 'SetDisplayNameScreen') {
            needsNavigation = true;
          } else if (targetRouteName == 'PairingScreen' && currentRouteName != 'PairingScreen') {
            needsNavigation = true;
          }

          // --- UNPAIR FIX: If we ARE on the dashboard but SHOULD be on the pairing screen, navigate ---
          if (targetRouteName == 'PairingScreen' && currentRouteName == '/dashboard') {
            debugPrint("[Nav Callback] Unpair detected! Navigating from Dashboard to PairingScreen.");
            needsNavigation = true;
          }
          // --- End UNPAIR FIX ---


          if (targetRouteName == _lastNavigatedRoute && needsNavigation) {
            debugPrint("[Nav Callback] Target route matches last navigated route. Skipping redundant navigation.");
            needsNavigation = false;
          }


          if (needsNavigation) {
            debugPrint("[Nav Callback] Needs navigation to $targetRouteName.");
            _lastNavigatedRoute = targetRouteName; // Store target before navigating

            if (targetRouteName == '/dashboard') {
              Navigator.pushReplacementNamed(context, targetRouteName, arguments: navigationArguments);
            } else if (targetRouteBuilder != null) {
              Navigator.pushReplacement(context, MaterialPageRoute(builder: targetRouteBuilder, settings: RouteSettings(name: targetRouteName)));
            } else {
              debugPrint("[Nav Callback] Error: Target route builder was null.");
              _lastNavigatedRoute = null; // Clear last target on error
            }
          } else {
            debugPrint("[Nav Callback] No navigation needed.");
            if (currentRouteName == targetRouteName || (targetRouteName == '/dashboard' && currentRouteName == '/dashboard')) {
              _lastNavigatedRoute = null;
            }
          }
        });

        // Show loading indicator while waiting for the post-frame callback
        debugPrint("Pairing Check: Build complete, waiting for navigation callback.");
        return const Scaffold(body: Center( child: CircularProgressIndicator(color: AppColors.accentOrange), ), );
      },
    );
  }
}
// --- End FIX ---


// --- Screen 1: Auth Screen ---
class AuthScreen extends StatefulWidget {
  const AuthScreen({super.key});
  @override State<AuthScreen> createState() => _AuthScreenState();
}
class _AuthScreenState extends State<AuthScreen> {
  final FirebaseAuthService _authService = FirebaseAuthService();
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  bool _isLoading = false;
  bool _isSignUpMode = false;
  // --- ⚠️ NEW: Password visibility state ---
  bool _obscurePassword = true;

  Future<void> _handleAuthAction(BuildContext context) async {
    FocusScope.of(context).unfocus(); // Hide keyboard
    if (_isLoading) return; // Prevent double taps
    setState(() { _isLoading = true; });

    User? user;
    final email = _emailController.text.trim();
    final password = _passwordController.text.trim();

    try {
      if (_isSignUpMode) {
        user = await _authService.signUpWithEmail(email, password);
      } else {
        user = await _authService.signInWithEmail(email, password);
      }
    } finally {
      // Ensure loading state is reset even if errors occur, but only if mounted
      if (mounted) {
        setState(() { _isLoading = false; });
      }
    }

    // Show error message if auth failed and widget is still mounted
    if (user == null && mounted) {
      // --- ⚠️ MOUNTED CHECK FIX ---
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(_isSignUpMode ? 'Sign up failed. Check details or email might be in use.' : 'Sign in failed. Please check credentials.'),
          backgroundColor: AppColors.errorRed,
        ),
      );
    }
    // Successful auth is handled by the root StreamBuilder
  }
  Future<void> _handleGoogleSignIn(BuildContext context) async {
    FocusScope.of(context).unfocus(); // Hide keyboard
    if (_isLoading) return; // Prevent double taps
    setState(() { _isLoading = true; });

    User? user;
    try {
      user = await _authService.signInWithGoogle();
    } finally {
      // Ensure loading state is reset even if errors occur, but only if mounted
      if (mounted) {
        setState(() { _isLoading = false; });
      }
    }

    // Show error message if auth failed and widget is still mounted
    if (user == null && mounted) {
      // --- ⚠️ MOUNTED CHECK FIX ---
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Google Sign-In failed. Check console/setup (SHA-1/Client ID).'),
          backgroundColor: AppColors.errorRed,
        ),
      );
    }
    // Successful auth is handled by the root StreamBuilder
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: GradientBackground(
        child: ResponsiveCenter(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(32.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon( Icons.favorite_rounded, color: AppColors.accentOrange, size: 80, ),
                const SizedBox(height: 16),
                Text( 'Heart to Heart', style: AppTextStyles.headline1, ),
                const SizedBox(height: 8),
                Text( 'Stay connected, instantly.', style: AppTextStyles.bodyText.copyWith(color: AppColors.textSecondary), ),
                const SizedBox(height: 64),
                TextField( controller: _emailController, decoration: InputDecoration( hintText: 'Email', prefixIcon: Icon(Icons.email_rounded, color: AppColors.textSecondary), ), keyboardType: TextInputType.emailAddress, style: AppTextStyles.bodyText, textInputAction: TextInputAction.next, ),
                const SizedBox(height: 16),
                // --- ⚠️ NEW: Password Field with Visibility Toggle ---
                TextField(
                  controller: _passwordController,
                  obscureText: _obscurePassword,
                  decoration: InputDecoration(
                    hintText: 'Password',
                    prefixIcon: Icon(Icons.lock_rounded, color: AppColors.textSecondary),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscurePassword ? Icons.visibility_off_rounded : Icons.visibility_rounded,
                        color: AppColors.textSecondary,
                      ),
                      onPressed: () {
                        setState(() {
                          _obscurePassword = !_obscurePassword;
                        });
                      },
                    ),
                  ),
                  style: AppTextStyles.bodyText,
                  textInputAction: TextInputAction.done,
                  onSubmitted: (_) => _handleAuthAction(context),
                ),
                // --- End New Password Field ---
                const SizedBox(height: 32),
                _isLoading
                    ? const CircularProgressIndicator(color: AppColors.accentOrange)
                    : Column(
                  children: [
                    ElevatedButton( onPressed: () => _handleAuthAction(context), child: Text(_isSignUpMode ? 'Sign Up' : 'Sign In'), ),
                    const SizedBox(height: 20),
                     Text('OR', style: TextStyle(color: AppColors.textSecondary)),
                    const SizedBox(height: 20),
                    ElevatedButton.icon( style: ElevatedButton.styleFrom( backgroundColor: AppColors.cardBackground, foregroundColor: AppColors.textPrimary, side: const BorderSide(color: Colors.white24), ),
                      // --- FIX: Use a non-GoogleFonts style for the "G"
                      icon: Container( width: 20, height: 20, alignment: Alignment.center, decoration: const BoxDecoration( color: Colors.white, shape: BoxShape.circle, ), child: Text( "G", style: const TextStyle( fontWeight: FontWeight.bold, color: Colors.blue, fontSize: 14 ), ), ),
                      label: const Text('Continue with Google'), onPressed: () => _handleGoogleSignIn(context),
                    ),
                    const SizedBox(height: 32),
                    Wrap( alignment: WrapAlignment.center, crossAxisAlignment: WrapCrossAlignment.center, children: [
                      Text( _isSignUpMode ? 'Already have an account?' : 'Don\'t have an account?', style: AppTextStyles.bodyText .copyWith(color: AppColors.textSecondary), ),
                      TextButton( onPressed: () { if (!_isLoading) setState(() => _isSignUpMode = !_isSignUpMode); }, child: Text(_isSignUpMode ? 'Sign In' : 'Sign Up'), ),
                    ],
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}


// --- Screen 2: Partner Pairing Screen ---
class PairingScreen extends StatefulWidget {
  const PairingScreen({super.key});
  @override State<PairingScreen> createState() => _PairingScreenState();
}
class _PairingScreenState extends State<PairingScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final FirestoreService _firestoreService = FirestoreService();
  final TextEditingController _codeInputController = TextEditingController();
  String? _generatedCode;
  bool _isGeneratingCode = false;
  bool _isSendingRequest = false;
  User? _currentUser;
  bool _alreadyPairedError = false;

  // State for request handling
  PairingStatus _pairingStatus = PairingStatus.idle;
  String? _sentRequestId;
  StreamSubscription? _outgoingRequestSub;
  StreamSubscription? _incomingRequestSub;

  // --- ⚠️ NEW: Listener for user data to fix pairing bug ---
  StreamSubscription? _userStreamSub;
  bool _isUserDocReady = false; // Tracks if we've received user data

  bool _showListenerErrorSnackbar = false; // Flag to show error message


  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _currentUser = FirebaseAuth.instance.currentUser;
    if (_currentUser != null) {
      // --- ⚠️ RE-PAIRING BUG FIX: Listen to user doc first ---
      _userStreamSub = _firestoreService.userStream.listen((userDoc) {
        if (!mounted) return;

        final partnerId = userDoc.data()?['partnerId'] as String?;
        debugPrint("[PairingScreen] User stream update: partnerId=$partnerId");

        // We are ready to generate a code ONLY if we are unpaired
        if (partnerId == null) {
          // --- ⚠️ RE-PAIRING BUG FIX: Check if we are ready OR if we need a code ---
          if (!_isUserDocReady || (_generatedCode == null && !_isGeneratingCode)) {
            debugPrint("[PairingScreen] User confirmed unpaired. Generating code.");
            _generateNewCode();
          }
          setState(() => _isUserDocReady = true); // Mark as ready
        } else {
          // This case shouldn't be hit if PairingChecker is working,
          // but as a safeguard, show the "already paired" error.
          debugPrint("[PairingScreen] User is still paired. Showing error.");
          setState(() {
            _isUserDocReady = true;
            _alreadyPairedError = true;
          });
        }
      });
      _listenForIncomingRequests(); // Start listening for others requesting us
    }
  }

  @override
  void dispose() {
    _tabController.dispose();
    _codeInputController.dispose();
    _outgoingRequestSub?.cancel(); // Cancel listener if active
    _incomingRequestSub?.cancel(); // Cancel listener
    _userStreamSub?.cancel(); // --- ⚠️ NEW: Cancel user listener
    super.dispose();
  }

  // Generates code, handles already paired case
  Future<void> _generateNewCode() async {
    // --- ⚠️ MODIFIED: Don't check user doc here, assume it's checked by listener ---
    if (_currentUser == null || !mounted || _isGeneratingCode) return;
    setState(() { _isGeneratingCode = true; _generatedCode = null; _alreadyPairedError = false;});

    try {
      // We call the service, which *will* re-check the user doc
      String? code = await _firestoreService.generatePairingCode(_currentUser!.uid);
      if (mounted) {
        setState(() {
          _generatedCode = code;
          _alreadyPairedError = (code == null); // This is the case where the service re-check fails
        });
      }
    } catch (e) {
      debugPrint("Error generating code: $e");
      if (mounted) {
        setState(() => _generatedCode = null);
        // --- ⚠️ MOUNTED CHECK FIX ---
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar( const SnackBar( content: Text('Failed to generate code.'), backgroundColor: AppColors.errorRed), );
        }
      }
    } finally {
      if(mounted) setState(() => _isGeneratingCode = false);
    }
  }

  // --- NEW: Listen for pairing requests directed at us ---
  void _listenForIncomingRequests() {
    _incomingRequestSub?.cancel(); // Cancel previous listener
    debugPrint("Listening for incoming pairing requests...");
    _incomingRequestSub = _firestoreService.getIncomingPairingRequests().listen(
            (snapshot) {
          debugPrint("[Listener] Incoming request stream update received.");
          if (!mounted) {
            debugPrint("[Listener] Widget not mounted, ignoring update.");
            return;
          }
          if (_showListenerErrorSnackbar) {
            debugPrint("[Listener] Resetting listener error flag.");
            setState(() => _showListenerErrorSnackbar = false);
          }

          debugPrint("[Listener] Found ${snapshot.docs.length} pending requests in snapshot.");
          if (snapshot.docs.isNotEmpty) {
            final request = snapshot.docs.first; // Get the latest pending request
            debugPrint("[Listener] Handling request ID: ${request.id}");
            _showPairingRequestDialog(request.id, request.data());
          } else {
            debugPrint("[Listener] No pending requests found.");
          }
        },
        onError: (error) {
          debugPrint("[Listener] Error listening for incoming requests: $error");
          if (mounted) {
            debugPrint("[Listener] Setting listener error flag to true.");
            setState(() => _showListenerErrorSnackbar = true);
          }
        }
    );
  }

  // --- NEW: Show dialog to accept/decline ---
  Future<void> _showPairingRequestDialog(String requestId, Map<String, dynamic> requestData) async {
    final requesterName = requestData['requesterName'] ?? 'Unknown User';
    final requesterId = requestData['requesterId'];
    if (!mounted) {
      debugPrint("[Dialog] Attempted to show dialog, but widget not mounted.");
      return;
    }

    final currentRoute = ModalRoute.of(context);
    final isCurrent = currentRoute?.isCurrent ?? false;
    final isPopup = currentRoute is PopupRoute;
    debugPrint("[Dialog] Checking if route is current: $isCurrent, Is Popup: $isPopup");
    if (!isCurrent || isPopup) {
      debugPrint("[Dialog] Skipping dialog, route is not current or a popup is already showing.");
      return;
    }

    debugPrint("[Dialog] Displaying confirmation dialog for request $requestId...");
    final confirmed = await showDialog<bool>(
        context: context,
        barrierDismissible: false, // Prevent dismissing by tapping outside
        builder: (context) => AlertDialog(
          backgroundColor: AppColors.cardBackground,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          title: Text('Pairing Request', style: AppTextStyles.headline2.copyWith(fontSize: 20)),
          content: Text('$requesterName wants to pair with you. Accept?', style: AppTextStyles.bodyText),
          actionsPadding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
          actions: [
            Row(
              children: [
                Expanded( child: OutlinedButton( onPressed: () => Navigator.of(context).pop(false), child: const Text('Decline'), ), ),
                const SizedBox(width: 8),
                Expanded( child: ElevatedButton( onPressed: () => Navigator.of(context).pop(true), child: const Text('Accept'), ), ),
              ],
            ),
          ],
        )
    ) ?? false;

    if (!mounted) {
      debugPrint("[Dialog] Dialog closed, but widget not mounted.");
      return;
    }

    if (confirmed) {
      debugPrint("[Dialog] User ACCEPTED request $requestId from $requesterId");
      bool success = await _firestoreService.acceptPairingRequest(requestId, requesterId);
      if (mounted && !success) { // Show error only if accept failed
        debugPrint("[Dialog] Acceptance Firestore call failed.");
        // --- ⚠️ MOUNTED CHECK FIX ---
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Failed to accept request. Maybe one user got paired?'), backgroundColor: AppColors.errorRed));
        }
      } else if (mounted && success) {
        debugPrint("[Dialog] Acceptance Firestore call successful.");
        // Navigation is handled by PairingCheckerScreen stream
      }
    } else {
      debugPrint("[Dialog] User DECLINED request $requestId");
      await _firestoreService.declinePairingRequest(requestId);
      // No UI feedback needed here, requester will see status change
    }
  }

  // --- ⚠️ RE-PAIRING BUG FIX: Renamed _isPairing to _isSendingRequest ---
  Future<void> _sendPairingRequest() async {
    if (_currentUser == null || !mounted || _isSendingRequest) return;
    FocusScope.of(context).unfocus();
    final code = _codeInputController.text.trim(); // Trim whitespace
    if (code.length != 6 || int.tryParse(code) == null) {
      // --- ⚠️ MOUNTED CHECK FIX ---
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar( const SnackBar( content: Text('Please enter a valid 6-digit code.'), backgroundColor: AppColors.errorRed), );
      }
      return;
    }
    setState(() { _isSendingRequest = true; _pairingStatus = PairingStatus.requestSent; }); // Indicate request sent
    _sentRequestId = null; // Clear previous request ID
    _outgoingRequestSub?.cancel(); // Cancel previous listener

    try {
      String? result = await _firestoreService.sendPairingRequest(code, _currentUser!.uid);

      if (!mounted) return;

      if (result == "failed_already_paired") {
        setState(() { _pairingStatus = PairingStatus.failedAlreadyPaired; _isSendingRequest = false; });
        // --- ⚠️ MOUNTED CHECK FIX ---
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar( const SnackBar( content: Text('You or the other user is already paired.'), backgroundColor: AppColors.errorRed), );
        }
      } else if (result != null) {
        // Request sent successfully, store ID and start listening
        _sentRequestId = result;
        _listenToOutgoingRequest(_sentRequestId!);
        debugPrint("Request sent, listening to ID: $_sentRequestId");
      }
      else { // result is null - invalid code or other error
        setState(() { _pairingStatus = PairingStatus.failedError; _isSendingRequest = false; });
        // --- ⚠️ MOUNTED CHECK FIX ---
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar( const SnackBar( content: Text('Invalid code or failed to send request.'), backgroundColor: AppColors.errorRed), );
        }
      }
    } catch (e) {
      debugPrint("Error sending pairing request: $e");
      if (mounted) {
        setState(() { _pairingStatus = PairingStatus.failedError; _isSendingRequest = false; });
        // --- ⚠️ MOUNTED CHECK FIX ---
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar( const SnackBar( content: Text('Failed to send pairing request.'), backgroundColor: AppColors.errorRed), );
        }
      }
    }
  }

  // --- NEW: Listen to the status of the request we sent ---
  void _listenToOutgoingRequest(String requestId) {
    _outgoingRequestSub = _firestoreService.getOutgoingPairingRequestStatus(requestId).listen(
            (snapshot) {
          if (!mounted) return;
          if (!snapshot.exists) {
            debugPrint("Outgoing request $requestId not found.");
            if (_pairingStatus == PairingStatus.requestSent) { // Only reset if we were waiting
              setState(() { _pairingStatus = PairingStatus.failedError; _isSendingRequest = false; });
              // --- ⚠️ MOUNTED CHECK FIX ---
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Pairing request expired or failed.'), backgroundColor: AppColors.errorRed));
              }
            }
            return;
          }

          final status = snapshot.data()?['status'] as String?;
          debugPrint("Outgoing request $requestId status updated: $status");

          switch (status) {
            case 'accepted':
              setState(() => _pairingStatus = PairingStatus.accepted);
              // --- ⚠️ MOUNTED CHECK FIX ---
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Partner accepted!'), backgroundColor: Colors.green));
              }
              _outgoingRequestSub?.cancel(); // Stop listening
              _isSendingRequest = false; // Reset pairing state
              // Navigation is handled by PairingCheckerScreen stream
              break;

            case 'declined':
              setState(() { _pairingStatus = PairingStatus.declined; _isSendingRequest = false; });
              // --- ⚠️ MOUNTED CHECK FIX ---
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Partner declined the request.'), backgroundColor: AppColors.errorRed));
              }
              _outgoingRequestSub?.cancel(); // Stop listening
              break;
            case 'failed_already_paired':
              setState(() { _pairingStatus = PairingStatus.failedAlreadyPaired; _isSendingRequest = false; });
              // --- ⚠️ MOUNTED CHECK FIX ---
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Pairing failed: One user was already paired.'), backgroundColor: AppColors.errorRed));
              }
              _outgoingRequestSub?.cancel(); // Stop listening
              break;
            case 'pending':
            // Still waiting, do nothing, UI shows "Waiting..."
              break;
            default: // Includes error states or unexpected values
              if (_pairingStatus == PairingStatus.requestSent) {
                setState(() { _pairingStatus = PairingStatus.failedError; _isSendingRequest = false; });
                if (status != 'cancelled_by_requester') {
                  // --- ⚠️ MOUNTED CHECK FIX ---
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Pairing failed unexpectedly.'), backgroundColor: AppColors.errorRed));
                  }
                }
              }
              _outgoingRequestSub?.cancel(); // Stop listening
              break;
          }
        },
        onError: (error) {
          debugPrint("Error listening to outgoing request $requestId: $error");
          if (mounted && _pairingStatus == PairingStatus.requestSent) {
            setState(() { _pairingStatus = PairingStatus.failedError; _isSendingRequest = false; });
            // --- ⚠️ MOUNTED CHECK FIX ---
            if (mounted) {
              ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Error checking pairing status.'), backgroundColor: AppColors.errorRed));
            }
          }
        }
    );
  }


  @override
  Widget build(BuildContext context) {
    if (_showListenerErrorSnackbar) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
            content: Text('Error receiving pairing requests. Check Firestore index & console.'),
            backgroundColor: AppColors.errorRed,
            duration: Duration(seconds: 5),
          ));
          setState(() => _showListenerErrorSnackbar = false);
        }
      });
    }

    return Scaffold(
      appBar: AppBar(
        title: Text('Pair with your Partner', style: AppTextStyles.headline2.copyWith(fontSize: 20)), centerTitle: true,
        bottom: TabBar( controller: _tabController, tabs: const [ Tab(text: 'My Code'), Tab(text: 'Enter Code'), ], ),
      ),
      body: GradientBackground(
        child: TabBarView(
          controller: _tabController,
          children: [
            SingleChildScrollView(child: _buildGenerateCodeTab()),
            SingleChildScrollView(child: _buildEnterCodeTab()),
          ],
        ),
      ),
    );
  }

  // Builds the UI for the 'My Code' tab
  Widget _buildGenerateCodeTab() {
    return ResponsiveCenter( child: Padding( padding: const EdgeInsets.symmetric(horizontal: 32.0, vertical: 64.0),
      child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [
        Text(
          _alreadyPairedError
              ? 'You are already paired. Unpair first to get a new code.'
              : 'Share this code with your partner:',
          textAlign: TextAlign.center,
          style: AppTextStyles.bodyText.copyWith(color: _alreadyPairedError ? AppColors.errorRed: AppColors.textSecondary),
        ),
        const SizedBox(height: 32),
        AnimatedSwitcher(
          duration: const Duration(milliseconds: 300),
          // --- ⚠️ RE-PAIRING BUG FIX: Show loading until doc is ready AND code is generated ---
          child: !_isUserDocReady || _isGeneratingCode
              ? const Padding( key: ValueKey('gen-loading'), padding: EdgeInsets.symmetric(vertical: 24.0), child: CircularProgressIndicator(color: AppColors.accentOrange), )
              : _generatedCode != null
              ? _buildCodeDisplay()
              : _alreadyPairedError
              ? _buildAlreadyPairedDisplay()
              : _buildCodeErrorDisplay(),
        ),
        if (!_alreadyPairedError && _isUserDocReady) // --- ⚠️ NEW: Hide button until ready
          TextButton.icon(
            icon: const Icon(Icons.refresh_rounded, size: 18),
            label: const Text('Generate New Code'),
            onPressed: _isGeneratingCode ? null : _generateNewCode, // Disable while generating
          ),

      ],
      ),
    ),
    );
  }
  Widget _buildCodeDisplay() {
    return Container(
      key: const ValueKey('code-display'), // Key for AnimatedSwitcher
      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
      decoration: BoxDecoration( color: AppColors.cardBackground, borderRadius: BorderRadius.circular(16), ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        mainAxisSize: MainAxisSize.min, // Prevent row taking full width
        children: [
          Flexible(
            child: FittedBox(
              fit: BoxFit.scaleDown, // Scale down if too wide
              child: Text(
                _generatedCode!.split('').join(' '),
                style: AppTextStyles.pairingCodeStyle, // Use defined style
                maxLines: 1, // Ensure it stays on one line
              ),
            ),
          ),
          const SizedBox(width: 16),
          IconButton(
            icon: const Icon(Icons.copy_rounded, color: AppColors.accentOrange),
            tooltip: 'Copy Code', // Add tooltip
            onPressed: () {
              if (_generatedCode != null) {
                Clipboard.setData(ClipboardData(text: _generatedCode!));
                // --- ⚠️ MOUNTED CHECK FIX ---
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Pairing code copied!'),
                      backgroundColor: Colors.green,
                      duration: Duration(seconds: 2),
                    ),
                  );
                }
              }
            },
          ),
        ],
      ),
    );
  }
  Widget _buildAlreadyPairedDisplay() {
    return const Padding(
      key: ValueKey('already-paired'),
      padding: EdgeInsets.symmetric(vertical: 24.0),
      child: Icon(Icons.link_off_rounded, color: AppColors.errorRed, size: 60),
    );
  }
  Widget _buildCodeErrorDisplay() {
    return Padding(
      key: const ValueKey('code-error'), // Key for AnimatedSwitcher
      padding: const EdgeInsets.symmetric(vertical: 24.0),
      child: Column( // Use Column for text and retry button
        children: [
          Text( 'Failed to generate code.\nPlease check connection.', textAlign: TextAlign.center, style: AppTextStyles.bodyText .copyWith(color: AppColors.errorRed), ),
        ],
      ),
    );
  }


  // Builds the UI for the 'Enter Code' tab - UPDATED
  Widget _buildEnterCodeTab() {
    return ResponsiveCenter( child: Padding( padding: const EdgeInsets.symmetric(horizontal: 32.0, vertical: 64.0),
      child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [
        Text(
          _pairingStatus == PairingStatus.requestSent
              ? 'Waiting for partner to accept...'
              : 'Enter your partner\'s 6-digit code:',
          textAlign: TextAlign.center,
          style: AppTextStyles.bodyText.copyWith(color: AppColors.textSecondary),
        ),
        const SizedBox(height: 32),

        if (_pairingStatus != PairingStatus.requestSent)
          TextField(
            controller: _codeInputController,
            textAlign: TextAlign.center,
            // --- ⚠️ NEW: Style for hint text ---
            style: AppTextStyles.headline1.copyWith(fontSize: 32, letterSpacing: 10), // Add letter spacing to text
            keyboardType: TextInputType.number,
            inputFormatters: [ FilteringTextInputFormatter.digitsOnly, LengthLimitingTextInputFormatter(6), ],
            decoration: InputDecoration(
              hintText: '_ _ _ _ _ _', // --- ⚠️ NEW: Hint text with spaces ---
              hintStyle: AppTextStyles.headline1.copyWith(
                color: AppColors.textSecondary.withAlpha(100), // Lighter hint
                fontSize: 32,
                letterSpacing: 10, // --- ⚠️ NEW: Add letter spacing to hint ---
              ),
            ),
            onSubmitted: (_) => _sendPairingRequest(),
            enabled: !_isSendingRequest && _pairingStatus != PairingStatus.requestSent,
          )
        else
          Padding( // Show progress indicator while waiting
            padding: const EdgeInsets.symmetric(vertical: 24.0),
            child: CircularProgressIndicator(color: AppColors.accentOrange),
          ),

        const SizedBox(height: 32),
        _isSendingRequest
            ? (_pairingStatus == PairingStatus.requestSent
            ? OutlinedButton.icon( // Allow cancelling the wait
          icon: const Icon(Icons.cancel_rounded, size: 18),
          label: const Text('Cancel Request'),
          onPressed: () {
            _outgoingRequestSub?.cancel(); // Stop listening
            if (_sentRequestId != null) {
              FirebaseFirestore.instance.collection('pairing_requests')
                  .doc(_sentRequestId!).update({'status': 'cancelled_by_requester'});
            }
            setState(() {
              _pairingStatus = PairingStatus.idle;
              _isSendingRequest = false;
              _sentRequestId = null;
            });
          },
        )
            : const CircularProgressIndicator(color: AppColors.accentOrange) // Show spinner while initially sending
        )
            : ElevatedButton.icon( // Show Connect button
          icon: const Icon(Icons.link_rounded),
          label: const Text('Connect'),
          onPressed: _sendPairingRequest,
        ),
      ],
      ),
    ),
    );
  }
}
// --- End FIX ---


// --- Screen 3: Set Display Name Screen ---
class SetDisplayNameScreen extends StatefulWidget {
  const SetDisplayNameScreen({super.key});
  @override State<SetDisplayNameScreen> createState() => _SetDisplayNameScreenState();
}
class _SetDisplayNameScreenState extends State<SetDisplayNameScreen> {
  final TextEditingController _nameController = TextEditingController();
  final FirestoreService _firestoreService = FirestoreService();
  bool _isLoading = false;
  String? _partnerId;

  @override void initState() {
    super.initState();
    final user = FirebaseAuth.instance.currentUser;
    _nameController.text = user?.displayName ?? user?.email?.split('@')[0] ?? '';
    _fetchPartnerId();
  }

  Future<void> _fetchPartnerId() async {
    try {
      final userDoc = await _firestoreService.userStream
          .where((doc) => doc.exists && doc.data()?['partnerId'] != null)
          .first
          .timeout(const Duration(seconds: 10));

      if (mounted) {
        setState(() {
          _partnerId = userDoc.data()?['partnerId'] as String?;
          debugPrint("Fetched partnerId: $_partnerId"); // Debugging
        });
      }
    } catch (e) {
      debugPrint("Error fetching partnerId for navigation: $e");
      if (mounted) {
        // --- ⚠️ MOUNTED CHECK FIX ---
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Error getting partner data. Try restarting.'), backgroundColor: AppColors.errorRed));
      }
    }
  }
  Future<void> _saveName() async {
    FocusScope.of(context).unfocus(); // Hide keyboard
    final name = _nameController.text.trim();
    if (name.isEmpty) {
      // --- ⚠️ MOUNTED CHECK FIX ---
      if(mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content:Text('Please enter a name.'), backgroundColor:AppColors.errorRed));
      return;
    }
    if (_partnerId == null) {
      debugPrint("Save Name Error: partnerId is null. Cannot navigate.");
      // --- ⚠️ MOUNTED CHECK FIX ---
      if(mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content:Text('Error finding partner data. Please restart.'), backgroundColor:AppColors.errorRed));
      setState(() => _isLoading = false); // Ensure loading stops
      return;
    }

    if (_isLoading) return; // Prevent double taps
    setState(() {_isLoading = true;});
    try {
      await _firestoreService.updateDisplayName(name);
      debugPrint("Name saved successfully."); // Debugging
      if (mounted) {
        // --- ⚠️ MOUNTED CHECK FIX ---
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content:Text('Name saved!'), backgroundColor:Colors.green, duration: Duration(seconds: 2)));
        // Navigation is handled by PairingCheckerScreen stream
      }

    } catch (e) {
      debugPrint("Error saving name: $e");
      if (mounted) {
        // --- ⚠️ MOUNTED CHECK FIX ---
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content:Text('Failed to save name. Check connection/permissions.'), backgroundColor:AppColors.errorRed));
        setState(() {_isLoading = false;}); // Reset loading on error
      }
    }
  }

  @override Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title:Text('One last step...', style:AppTextStyles.headline2.copyWith(fontSize: 20)), centerTitle:true, automaticallyImplyLeading: false,), // Remove back button
      body: GradientBackground(child: ResponsiveCenter(child: Padding(padding: const EdgeInsets.all(32.0),
        child: SingleChildScrollView( // Prevent overflow with keyboard
          child: Column(mainAxisAlignment: MainAxisAlignment.center, children: [
            Text('How should your partner see you?', textAlign:TextAlign.center, style:AppTextStyles.headline2),
            const SizedBox(height: 32),
            TextField( controller:_nameController, textAlign:TextAlign.center, style:AppTextStyles.bodyText, decoration:const InputDecoration(hintText:'Enter your name'), textInputAction: TextInputAction.done, onSubmitted: (_) => _saveName(), ),
            const SizedBox(height: 32),
            _isLoading
                ? const CircularProgressIndicator(color:AppColors.accentOrange)
                : ElevatedButton(onPressed: _partnerId == null ? null : _saveName, child:const Text('Continue')),
          ],
          ),
        ),
      ), ), ),
    );
  }
}

// --- Screen 4: Dashboard ---
class DashboardScreen extends StatefulWidget {
  final String partnerId;
  const DashboardScreen({super.key, required this.partnerId});
  @override State<DashboardScreen> createState() => _DashboardScreenState();
}

// --- ⚠️ MODIFIED: Added WidgetsBindingObserver for Presence ---
class _DashboardScreenState extends State<DashboardScreen> with WidgetsBindingObserver {
  int _selectedIndex = 0;
  final FirestoreService _firestoreService = FirestoreService();
  StreamSubscription? _notificationSub;
  bool _isFirstNotificationLoad = true;
  late final List<Widget> _widgetOptions;

  // --- ⚠️ NEW: Stream listener for self to detect unpair ---
  StreamSubscription? _selfUserStreamSub;

  @override
  void initState() {
    super.initState();
    _widgetOptions = <Widget>[
      _DashboardHomeTab(partnerId: widget.partnerId),
      _DashboardHistoryTab(partnerId: widget.partnerId),
      _DashboardProfileTab(partnerId: widget.partnerId),
    ];
    _notificationSub = _firestoreService.getNotificationsStream().listen( _handleNotificationSnapshot, onError: (error) { debugPrint("Vibration Notification Stream Error: $error"); } );

    // --- ⚠️ NEW: Presence Management ---
    WidgetsBinding.instance.addObserver(this);
    _firestoreService.updateUserPresence(true); // Set Online on init

    // --- ⚠️ NEW: Listen to self for unpair ---
    _selfUserStreamSub = _firestoreService.userStream.listen((snapshot) {
      // --- ⚠️ MOUNTED CHECK FIX ---
      if (!mounted) return;

      if (snapshot.exists && snapshot.data()?['partnerId'] == null) {
        // We have been unpaired!
        debugPrint("Dashboard listener: partnerId is null. Navigating to /checker.");
        if (mounted) {
          // Use rootNavigator to clear the dashboard stack and force re-check
          Navigator.of(context, rootNavigator: true).pushAndRemoveUntil(
              MaterialPageRoute(builder: (_) => const PairingCheckerScreen(), settings: const RouteSettings(name: '/checker')),
                  (route) => false
          );
        }
      }
    }, onError: (e) {
      debugPrint("Error listening to self-stream: $e");
    });
  }

  @override
  void dispose() {
    _notificationSub?.cancel();
    _selfUserStreamSub?.cancel(); // --- ⚠️ NEW: Cancel self listener
    // --- Presence Management ---
    WidgetsBinding.instance.removeObserver(this);
    // Note: We don't set offline on dispose, only on pause/detach
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    // --- ⚠️ NEW: Update presence based on app state ---
    if (state == AppLifecycleState.resumed) {
      _firestoreService.updateUserPresence(true); // Online
    } else {
      // (paused, inactive, detached, hidden)
      _firestoreService.updateUserPresence(false); // Offline
    }
  }
  // --- End Presence Management ---

  Future<void> _handleNotificationSnapshot(QuerySnapshot snapshot) async {
    debugPrint("Vibration: Snapshot received with ${snapshot.docChanges.length} changes."); // --- DEBUG LOG ---
    if (_isFirstNotificationLoad) {
      debugPrint("Vibration: First load, skipping vibration."); // --- DEBUG LOG ---
      _isFirstNotificationLoad = false;
      return;
    }

    for (var change in snapshot.docChanges) {
      if (change.type == DocumentChangeType.added) {
        debugPrint("Vibration: 'added' change detected."); // --- DEBUG LOG ---
        try {
          final data = change.doc.data() as Map<String, dynamic>?;
          final senderId = data?['senderId'] as String?;
          if (senderId != null && senderId != FirebaseAuth.instance.currentUser?.uid) {
            debugPrint("Vibration: Sender is partner."); // --- DEBUG LOG ---
            final timestamp = data?['timestamp'] as Timestamp?;
            if (timestamp != null) {
              final age = DateTime.now().difference(timestamp.toDate());
              if (age.inSeconds < 10) { // Only vibrate for very new messages from partner
                debugPrint("Vibration: Message is new, VIBRATING."); // --- DEBUG LOG ---
                _vibrate();
              } else {
                debugPrint("Vibration: Message is old (${age.inSeconds}s), skipping."); // --- DEBUG LOG ---
              }
            }
          } else {
            debugPrint("Vibration: Sender is current user, skipping."); // --- DEBUG LOG ---
          }
        } catch (e) {
          debugPrint("Error processing notification for vibration: $e");
        }
      }
    }
  }
  Future<void> _vibrate() async {
    try {
      bool? hasVibrator = await Vibration.hasVibrator();
      if (hasVibrator == true) {
        debugPrint("Vibration: Device has vibrator, calling vibrate()."); // --- DEBUG LOG ---
        Vibration.vibrate(duration: 200); // Vibrate for 200ms
      } else {
        debugPrint("Vibration: Device has NO vibrator."); // --- DEBUG LOG ---
      }
    } catch (e) {
      debugPrint("Could not vibrate: $e");
    }
  }
  void _onItemTapped(int index) { setState(() { _selectedIndex = index; }); }

  @override Widget build(BuildContext context) {
    return Scaffold(
      extendBody: true,
      appBar: AppBar(
        title: _buildAppBarTitle(),
        centerTitle: true,
        automaticallyImplyLeading: false, // Remove back button on dashboard
      ),
      body: IndexedStack(
        index: _selectedIndex,
        children: _widgetOptions,
      ),
      bottomNavigationBar: Container(
        decoration: BoxDecoration(
          color: AppColors.bottomNavBackground.withOpacity(0.85),
        ),
        child: ClipRect( // Clip the blur effect
          child: BackdropFilter(
            filter: ImageFilter.blur(sigmaX: 10.0, sigmaY: 10.0), // Apply blur
            child: BottomNavigationBar(
              items: const <BottomNavigationBarItem>[
                BottomNavigationBarItem( icon: Icon(Icons.favorite_rounded), label: 'Home', ),
                BottomNavigationBarItem( icon: Icon(Icons.history_rounded), label: 'History', ),
                BottomNavigationBarItem( icon: Icon(Icons.person_rounded), label: 'Profile', ),
              ],
              currentIndex: _selectedIndex,
              onTap: _onItemTapped,
            ),
          ),
        ),
      ),
    );
  }
  Widget _buildAppBarTitle() {
    if (_selectedIndex == 2) { // Profile Tab
      return Text('Profile & Settings', style: AppTextStyles.headline2.copyWith(fontSize: 20));
    }
    if (_selectedIndex == 1) { // History Tab
      return Text('Recent Activity', style: AppTextStyles.headline2.copyWith(fontSize: 20));
    }

    // Default: Home Tab Title
    return Row(
      mainAxisAlignment: MainAxisAlignment.center, // Center the row content
      mainAxisSize: MainAxisSize.min, // Take minimum space needed
      children: [
        // --- ⚠️ REMOVED Partner Name Column, it's in the new card ---
        // Streak Counter (Your Streak)
        StreamBuilder<DocumentSnapshot<Map<String, dynamic>>>(
          stream: _firestoreService.userStream,
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              debugPrint("Dashboard listener: waiting for user data...");
            }
            if (!snapshot.hasData || !snapshot.data!.exists) {
              return const SizedBox.shrink();
            }
            final streakCount = snapshot.data?.data()?['currentStreak'] as int? ?? 0;
            if (streakCount > 0) {
              return Row( mainAxisSize: MainAxisSize.min, children: [
                const Icon(Icons.local_fire_department_rounded, color: AppColors.streakFlame, size: 18),
                const SizedBox(width: 4),
                Text( '$streakCount', style: AppTextStyles.bodyText.copyWith(fontSize: 16, color: AppColors.streakFlame, fontWeight: FontWeight.bold), ),
              ],
              );
            } else {
              return const SizedBox.shrink();
            }
          },
        ),
      ],
    );
  }
}

// --- Tab Content for Dashboard: Home ---
class _DashboardHomeTab extends StatefulWidget {
  final String partnerId;
  const _DashboardHomeTab({required this.partnerId}); // Use required

  @override
  State<_DashboardHomeTab> createState() => _DashboardHomeTabState();
}
class _DashboardHomeTabState extends State<_DashboardHomeTab> with TickerProviderStateMixin {
  final FirestoreService _firestoreService = FirestoreService();
  double _buttonScale = 1.0;

  // --- Animation State ---
  OverlayEntry? _overlayEntry;
  final List<_HeartParticle> _particles = [];
  late AnimationController _animationController;
  final Random _random = Random();


  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 2),
    )..addListener(() {
      // Trigger rebuild for particle movement within the overlay
      _overlayEntry?.markNeedsBuild();
      // Remove particles that are done animating
      _particles.removeWhere((p) => !p.update()); // Update returns false when done
    })..addStatusListener((status) {
      // Automatically remove overlay when animation completes
      if (status == AnimationStatus.completed) {
        _removeOverlay();
      }
    });
  }

  @override
  void dispose() {
    _animationController.dispose();
    _removeOverlay(); // Ensure overlay is removed on dispose
    super.dispose();
  }

  // --- FIX: Cleaned up tap handlers ---
  void _onTapDown(TapDownDetails d) { setState(() => _buttonScale=0.9); }
  void _onTapCancel() { setState(() => _buttonScale=1.0); }

  // --- ⚠️ CHAT UI FIX: Changed messages to first-person ---
  void _handleSend(String msg, String emj) {
    setState(() => _buttonScale=1.0);
    _firestoreService.sendNotification(widget.partnerId, msg, emj);

    // Trigger heart animation only for the main button's message
    if (msg == "I miss you") { // More specific check
      _showHeartOverlay(context); // Pass context
    }

    if (mounted) {
      // --- ⚠️ MOUNTED CHECK FIX ---
      ScaffoldMessenger.of(context).showSnackBar(SnackBar( content: Text('Sent "$msg" $emj', style:AppTextStyles.bodyText), backgroundColor:AppColors.cardBackground, behavior:SnackBarBehavior.floating, shape:RoundedRectangleBorder(borderRadius:BorderRadius.circular(20)), margin:const EdgeInsets.all(16), duration: const Duration(seconds: 2), ));
    }
  }


  // --- Heart Animation Logic ---
  void _showHeartOverlay(BuildContext context) { // Requires context
    _removeOverlay(); // Ensure no duplicates

    final size = MediaQuery.of(context).size;
    _particles.clear();
    for (int i = 0; i < 15; i++) {
      // Pass screen dimensions for positioning
      _particles.add(_HeartParticle(random: _random, screenWidth: size.width, screenHeight: size.height));
    }

    _overlayEntry = OverlayEntry(
      builder: (context) => IgnorePointer(
        child: CustomPaint( // Use CustomPaint for better performance
          painter: _HeartPainter(_particles, _animationController),
          size: size,
        ),
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
    _animationController.forward(from: 0.0);
  }

  void _removeOverlay() {
    _overlayEntry?.remove();
    _overlayEntry = null;
    _animationController.stop(); // Stop ticker
    _particles.clear(); // Clear particles after stopping
  }

  // --- Build Method for Home Tab ---
  @override
  Widget build(BuildContext context) {
    return GradientBackground(
      child: ResponsiveCenter(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24.0), // Consistent horizontal padding
          child: LayoutBuilder(builder: (ctx, cons) {
            return SingleChildScrollView(
              child: ConstrainedBox( // Ensure minimum height for centering
                constraints: BoxConstraints(minHeight: cons.maxHeight),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center, // Center vertically
                  children: [
                    // --- ⚠️ NEW: Partner Card ---
                    _buildPartnerCard(context),
                    Padding(
                      padding: EdgeInsets.symmetric(vertical: max(32.0, cons.maxHeight * 0.1)),
                      child: _buildMainButton(cons),
                    ),
                    _buildEmojiRow(),
                    const SizedBox(height: 100), // --- FIX: Increased space for glassy nav bar
                  ],
                ),
              ),
            );
          }),
        ),
      ),
    );
  }

  // --- ⚠️ NEW: Partner Card Widget ---
  Widget _buildPartnerCard(BuildContext context) {
    return StreamBuilder<DocumentSnapshot<Map<String, dynamic>>>(
      stream: _firestoreService.getPartnerStream(widget.partnerId),
      builder: (context, snapshot) {
        String partnerName = 'Your Partner';
        String status = 'Offline';
        Color statusColor = Colors.grey.shade500;
        String? photoUrl;

        if (snapshot.hasData && snapshot.data!.exists) {
          final partnerData = snapshot.data!.data();
          partnerName = partnerData?['displayName'] ?? 'Your Partner';
          photoUrl = partnerData?['photoURL'] as String?;
          final isOnline = partnerData?['isOnline'] as bool? ?? false;
          final lastSeen = partnerData?['lastSeen'] as Timestamp?;

          if (isOnline) {
            status = "Online";
            statusColor = Colors.greenAccent.shade400;
          } else if (lastSeen != null) {
            status = _formatTimeAgoShort(lastSeen);
          }
        }

        // Use an AnimatedSwitcher to fade between loading/content
        return AnimatedSwitcher(
          duration: const Duration(milliseconds: 300),
          child: snapshot.hasData
              ? Card(
            key: ValueKey('partner-card'),
            elevation: 0,
            color: AppColors.cardBackground.withOpacity(0.8),
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
              child: Row(
                children: [
                  CircleAvatar(
                    radius: 20,
                    backgroundColor: AppColors.primaryBackground,
                    backgroundImage: (photoUrl != null && photoUrl.isNotEmpty)
                        ? NetworkImage(photoUrl)
                        : null,
                    child: (photoUrl == null || photoUrl.isEmpty)
                        ?  Icon(Icons.person_rounded, size: 20, color: AppColors.textSecondary)
                        : null,
                  ),
                  const SizedBox(width: 12),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Connected to',
                        style: AppTextStyles.bodyText.copyWith(fontSize: 12, color: AppColors.textSecondary),
                      ),
                      Text(
                        partnerName,
                        style: AppTextStyles.bodyText.copyWith(fontWeight: FontWeight.w600),
                      ),
                    ],
                  ),
                  const Spacer(),
                  Container(
                    width: 8, height: 8,
                    decoration: BoxDecoration(shape: BoxShape.circle, color: statusColor),
                  ),
                  const SizedBox(width: 6),
                  Text(status, style: AppTextStyles.bodyText.copyWith(fontSize: 12, color: statusColor)),
                ],
              ),
            ),
          )
              : Card( // Placeholder loading card
            key: ValueKey('loading-card'),
            elevation: 0,
            color: AppColors.cardBackground.withOpacity(0.8),
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
              child: Row(
                children: [
                  CircleAvatar(radius: 20, backgroundColor: AppColors.primaryBackground),
                  const SizedBox(width: 12),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text('Connecting...', style: AppTextStyles.bodyText.copyWith(fontSize: 12, color: AppColors.textSecondary)),
                      Text('Loading Partner', style: AppTextStyles.bodyText.copyWith(fontWeight: FontWeight.w600)),
                    ],
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  // --- ⚠️ NEW: Helper for card time ago ---
  String _formatTimeAgoShort(Timestamp timestamp) {
    final now = DateTime.now();
    final dt = timestamp.toDate();
    final difference = now.difference(dt);

    if (difference.inSeconds < 120) return '1m ago'; // 2 minutes
    if (difference.inMinutes < 60) return '${difference.inMinutes}m ago';
    if (difference.inHours < 24) return '${difference.inHours}h ago';
    if (difference.inDays == 1) return '1d ago';
    return '${difference.inDays}d ago';
  }


  // Helper for the main heart button
  Widget _buildMainButton(BoxConstraints c) {
    final s = (c.maxWidth * 0.6).clamp(150.0, 250.0);
    return GestureDetector(
        onTapDown:_onTapDown,
        // --- ⚠️ CHAT UI FIX: Use first-person message ---
        onTapUp:(d) => _handleSend("I miss you","❤️"),
        onTapCancel:_onTapCancel,
        child:AnimatedScale( scale:_buttonScale, duration:const Duration(milliseconds:150), curve:Curves.easeInOut,
            child:Container( width:s, height:s, decoration:BoxDecoration( shape:BoxShape.circle, color:AppColors.accentOrange, boxShadow:[BoxShadow(color:AppColors.accentOrange.withAlpha(102), blurRadius:30, spreadRadius:8)] ), child:Center(child:Icon(Icons.favorite_rounded, color:AppColors.textPrimary, size:s*0.5)) )
        )
    );
  }

  // Helper for the row of emoji buttons
  Widget _buildEmojiRow() {
    // --- ⚠️ CHAT UI FIX: Use first-person messages ---
    final emojis = [
      {'e':'🥺','l':'Miss You','m':'I\'m missing you'},
      {'e':'❤️','l':'Love You','m':'I love you'},
      {'e':'😢','l':'Sad','m':'I\'m feeling sad'},
      {'e':'🤩','l':'Excited','m':'I\'m excited!'},
      {'e':'💭','l':'Thinking','m':'I\'m thinking of you'}
    ];
    return Wrap( alignment:WrapAlignment.spaceAround, spacing:16.0, runSpacing:16.0, children:emojis.map((i)=>EmojiButton( emoji:i['e']!, label:i['l']!, onPressed:()=> _handleSend(i['m']!,i['e']!) )).toList());
  }
}

// Custom Painter for Heart Animation
class _HeartPainter extends CustomPainter {
  final List<_HeartParticle> particles;
  final Animation<double> animation;

  _HeartPainter(this.particles, this.animation) : super(repaint: animation);

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = AppColors.accentOrange;

    for (var particle in particles) {
      // Calculate opacity based on animation progress and particle's own opacity
      final currentOpacity = particle.opacity * (1.0 - animation.value); // Fade out with animation value
      if (currentOpacity <= 0) continue; // Skip if faded out

      paint.color = AppColors.accentOrange.withOpacity(currentOpacity);

      // Simple heart shape drawing (approximation)
      final path = Path();
      path.moveTo(particle.x, particle.y - particle.size * 0.3); // Top indent
      path.cubicTo(particle.x + particle.size * 0.4, particle.y - particle.size * 0.7, // Top left curve
          particle.x + particle.size * 0.8, particle.y - particle.size * 0.3,
          particle.x, particle.y + particle.size * 0.5); // Bottom point
      path.cubicTo(particle.x - particle.size * 0.8, particle.y - particle.size * 0.3, // Top right curve back to start
          particle.x - particle.size * 0.4, particle.y - particle.size * 0.7,
          particle.x, particle.y - particle.size * 0.3);
      canvas.drawPath(path, paint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true; // Repaint whenever animation ticks
}


// Simple class to manage heart particle state for animation
class _HeartParticle {
  double x;
  double y;
  double size;
  double opacity;
  double speedY; // Vertical speed
  double speedX; // Horizontal drift
  final Random random;
  final double screenWidth;
  final double screenHeight;

  _HeartParticle({required this.random, required this.screenWidth, required this.screenHeight})
      : x = screenWidth / 2 + random.nextDouble() * 80 - 40, // Start near horizontal center
        y = screenHeight * 0.5 + random.nextDouble() * 50 - 25, // Start near vertical center
        size = random.nextDouble() * 15 + 10,
        opacity = random.nextDouble() * 0.3 + 0.7, // Start slightly less than full opacity (0.7-1.0)
        speedY = random.nextDouble() * -3 - 2, // Move UPWARDS
        speedX = random.nextDouble() * 2 - 1; // Slight horizontal drift (-1 to 1)

  // Update particle position and opacity, return true if still visible/active
  bool update() {
    y += speedY;
    x += speedX;
    opacity -= 0.02; // Fade out slightly faster
    // Particle is active if opacity > 0 and within reasonable y-bounds (e.g., above top of screen)
    return opacity > 0 && y > -size; // Check if still visible or about to become visible
  }
}


// --- Tab Content for Dashboard: History ---
class _DashboardHistoryTab extends StatelessWidget {
  final FirestoreService _firestoreService = FirestoreService();
  final String partnerId;
  final String? currentUserId = FirebaseAuth.instance.currentUser?.uid;

  // --- ⚠️ NEW: Partner and User data streams ---
  final Stream<DocumentSnapshot<Map<String, dynamic>>> partnerStream;
  final Stream<DocumentSnapshot<Map<String, dynamic>>> userStream;

  _DashboardHistoryTab({required this.partnerId})
      : partnerStream = FirestoreService().getPartnerStream(partnerId), // Init partner stream
        userStream = FirestoreService().userStream; // Init self stream

  String _formatTimestamp(Timestamp? t) {
    if (t == null) return "Sending...";
    final dt = t.toDate();
    final now = DateTime.now();
    final difference = now.difference(dt);

    if (difference.inSeconds < 60) return "Just now";
    if (difference.inMinutes < 60) return "${difference.inMinutes}m ago";
    if (difference.inHours < 24 && now.day == dt.day) return DateFormat('h:mm a').format(dt);
    if (difference.inDays < 2 && now.day == dt.day + 1) return "Yesterday"; // Simpler

    return DateFormat('MMM d, yyyy').format(dt); // e.g., Oct 25, 2024
  }


  @override
  Widget build(BuildContext context) {
    return GradientBackground(
      child: ResponsiveCenter(
        child: Padding(
          padding: const EdgeInsets.only(bottom: 90.0), // Padding for nav bar
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                // --- ⚠️ NEW: Load partner AND user data for names/photos ---
                child: StreamBuilder<DocumentSnapshot<Map<String, dynamic>>>(
                    stream: userStream,
                    builder: (context, userSnapshot) {
                      final myName = userSnapshot.data?.data()?['displayName'] ?? 'Me';
                      final myPhotoUrl = userSnapshot.data?.data()?['photoURL'] as String?;

                      return StreamBuilder<DocumentSnapshot<Map<String, dynamic>>>(
                          stream: partnerStream,
                          builder: (context, partnerSnapshot) {
                            final partnerName = partnerSnapshot.data?.data()?['displayName'] ?? 'Partner';
                            final partnerPhotoUrl = partnerSnapshot.data?.data()?['photoURL'] as String?;

                            return _buildNotificationList(
                              context: context, // --- ⚠️ CHAT UI FIX: Pass context ---
                              myName: myName,
                              myPhotoUrl: myPhotoUrl,
                              partnerName: partnerName,
                              partnerPhotoUrl: partnerPhotoUrl,
                            );
                          }
                      );
                    }
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Helper for the list of recent notifications
  Widget _buildNotificationList({
    required BuildContext context, // --- ⚠️ CHAT UI FIX: Pass context ---
    required String myName,
    String? myPhotoUrl,
    required String partnerName,
    String? partnerPhotoUrl,
  }) {
    return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
        stream:_firestoreService.getNotificationsStream(),
        builder:(c, s) {
          if(s.connectionState==ConnectionState.waiting) { return const Center(child:CircularProgressIndicator(color:AppColors.accentOrange)); }
          if(s.hasError){ debugPrint("Notification List Error: ${s.error}"); return const Center(child:Text('Could not load activity.\nCheck Firestore Rules.', textAlign: TextAlign.center,)); }
          if(!s.hasData||s.data!.docs.isEmpty){ return Center(child:Text( 'No recent activity.\nSend a message!', textAlign:TextAlign.center, style:AppTextStyles.bodyText.copyWith(color:AppColors.textSecondary) )); }

          final docs=s.data!.docs;
          return ListView.builder(
              reverse: true, // Show latest messages at the bottom
              padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
              itemCount:docs.length,
              itemBuilder:(c,i){
                final doc=docs[i].data();
                final m=doc['message'] as String? ??'...';
                final em=doc['emoji'] as String? ??'❤️';
                final t=doc['timestamp'] as Timestamp?;
                final senderId = doc['senderId'] as String?;
                final isMe = (senderId == currentUserId);

                // --- ⚠️ NEW: Grouping Logic ---
                bool isSameSenderAsPrevious = false;
                if (i < docs.length - 1) {
                  final prevDoc = docs[i + 1].data();
                  final prevSenderId = prevDoc['senderId'] as String?;
                  isSameSenderAsPrevious = (prevSenderId == senderId);
                }

                return _buildChatBubble(
                    context: context, // --- ⚠️ CHAT UI FIX: Pass context ---
                    emoji: em,
                    message: m,
                    timestamp: _formatTimestamp(t),
                    isMe: isMe,
                    senderName: isMe ? myName : partnerName,
                    senderPhotoUrl: isMe ? myPhotoUrl : partnerPhotoUrl,
                    showAvatar: !isSameSenderAsPrevious // Only show avatar if sender changed
                );
              }
          );
        }
    );
  }

  // --- ⚠️ CHAT UI FIX: Complete Redesign ---
  Widget _buildChatBubble({
    required BuildContext context,
    required String emoji,
    required String message,
    required String timestamp,
    required bool isMe,
    required String senderName,
    String? senderPhotoUrl,
    required bool showAvatar,
  }) {
    // --- ⚠️ FIX: "Me" (isMe) is RIGHT, "Partner" (!isMe) is LEFT ---
    final bubbleColor = isMe ? AppColors.chatBubbleMe : AppColors.chatBubblePartner;
    final alignment = isMe ? CrossAxisAlignment.end : CrossAxisAlignment.start;
    final tailBorderRadius = isMe
        ? BorderRadius.only(
      topLeft: Radius.circular(16),
      bottomLeft: Radius.circular(16),
      topRight: Radius.circular(16),
      bottomRight: Radius.circular(4), // Tail
    )
        : BorderRadius.only(
      topLeft: Radius.circular(4), // Tail
      bottomLeft: Radius.circular(16),
      topRight: Radius.circular(16),
      bottomRight: Radius.circular(16),
    );

    final avatar = _buildAvatar(senderName, senderPhotoUrl, showAvatar, isMe: isMe);

    final bubble = Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
      decoration: BoxDecoration(
        color: bubbleColor,
        borderRadius: tailBorderRadius,
      ),
      child: Column(
        crossAxisAlignment: alignment,
        children: [
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(emoji, style: const TextStyle(fontSize: 24)),
              const SizedBox(width: 8),
              Flexible(
                child: Text(
                  message,
                  style: AppTextStyles.chatBubbleMessage,
                ),
              ),
            ],
          ),
          SizedBox(height: 4),
          Text(
            timestamp,
            style: AppTextStyles.chatBubbleTimestamp,
          ),
        ],
      ),
    );

    // Get screen width for constraints
    final screenWidth = MediaQuery.of(context).size.width;

    return Container(
      margin: EdgeInsets.only(
        top: showAvatar ? 12.0 : 4.0, // More space if avatar is shown
        bottom: 4.0,
      ),
      child: Row(
        // --- ⚠️ FIX: "Me" (isMe) aligns to MainAxisAlignment.end (right) ---
        mainAxisAlignment: isMe ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end, // Align avatar to bottom of bubble
        children: [
          // --- PARTNER (LEFT) ---
          if (!isMe) ...[
            avatar,
            SizedBox(width: 8),
          ],

          // --- BUBBLE (Constrained) ---
          Container(
            constraints: BoxConstraints(maxWidth: screenWidth * 0.75), // Bubble max width 75%
            child: bubble,
          ),

          // --- ME (RIGHT) ---
          if (isMe) ...[
            SizedBox(width: 8),
            avatar, // Avatar (will be hidden by _buildAvatar logic)
          ],
        ],
      ),
    );
  }

  Widget _buildAvatar(String name, String? photoUrl, bool showAvatar, {bool isMe = false}) {
    // --- ⚠️ CHAT UI FIX: Hide avatar for "Me" ---
    if (isMe) {
      return SizedBox(width: 40); // Maintain spacing but hide avatar
    }

    if (!showAvatar) {
      return SizedBox(width: 40); // Maintain spacing
    }

    String initials = name.isNotEmpty ? name[0].toUpperCase() : '?';

    return CircleAvatar(
      radius: 20,
      backgroundColor: AppColors.cardBackground,
      backgroundImage: (photoUrl != null && photoUrl.isNotEmpty)
          ? NetworkImage(photoUrl)
          : null,
      child: (photoUrl == null || photoUrl.isEmpty)
          ? Text(
        initials,
        style: AppTextStyles.buttonText.copyWith(fontSize: 18),
      )
          : null,
    );
  }
}
// --- End FIX ---


// --- Screen 5: Profile Screen ---
class _DashboardProfileTab extends StatefulWidget {
  final String? partnerId; // Partner ID is needed for unpairing
  const _DashboardProfileTab({this.partnerId});

  @override
  State<_DashboardProfileTab> createState() => _DashboardProfileTabState();
}

class _DashboardProfileTabState extends State<_DashboardProfileTab> {
  final FirestoreService _firestoreService = FirestoreService();
  final FirebaseStorageService _storageService = FirebaseStorageService(); // --- ⚠️ NEW
  final ImagePicker _picker = ImagePicker(); // --- ⚠️ NEW

  bool _isEditing = false;
  bool _isLoading = false; // General loading state
  bool _isUploading = false; // Specific for image upload

  // --- ⚠️ MODIFIED: New Controllers ---
  late TextEditingController _nameController;
  late TextEditingController _moodController;
  late TextEditingController _activityController;
  late TextEditingController _thoughtController;

  Map<String, dynamic> _userData = {}; // Holds current user data
  int _currentStreak = 0;
  String? _partnerName; // --- ⚠️ NEW
  Timestamp? _pairedAt; // --- ⚠️ NEW

  @override
  void initState() {
    super.initState();
    // --- ⚠️ MODIFIED: Init New Controllers ---
    _nameController = TextEditingController();
    _moodController = TextEditingController();
    _activityController = TextEditingController();
    _thoughtController = TextEditingController();
    // Load initial user data
    _loadUserData();
    _loadPartnerData(); // --- ⚠️ NEW
  }

  // Fetches user data from Firestore and populates controllers
  Future<void> _loadUserData() async {
    if (!mounted) return; // Prevent calls after dispose
    try {
      // Use the stream but only take the first non-null, existing value
      final userDoc = await _firestoreService.userStream.firstWhere((doc) => doc.exists);
      if (mounted) { // Check again after await
        setState(() {
          _userData = userDoc.data() ?? {};
          _nameController.text = _userData['displayName'] ?? '';

          // --- ⚠️ MODIFIED: Load New Fields ---
          _moodController.text = _userData['myMood'] ?? '';
          _activityController.text = _userData['myActivity'] ?? '';
          _thoughtController.text = _userData['thinkingOfYou'] ?? '';

          _currentStreak = _userData['currentStreak'] as int? ?? 0;
          _pairedAt = _userData['pairedAt'] as Timestamp?; // --- ⚠️ NEW
        });
      }
    } catch (e) {
      debugPrint("Error loading user data for profile: $e");
      if (mounted) {
        // --- ⚠️ MOUNTED CHECK FIX ---
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Could not load profile data.'), backgroundColor: AppColors.errorRed));
      }
    }
  }

  // --- ⚠️ NEW: Load partner data for "Connected since" card ---
  Future<void> _loadPartnerData() async {
    if (widget.partnerId == null || !mounted) return;
    try {
      final partnerDoc = await _firestoreService.getPartnerStream(widget.partnerId!).firstWhere((doc) => doc.exists);
      if (mounted) {
        setState(() {
          _partnerName = partnerDoc.data()?['displayName'] ?? 'Your Partner';
        });
      }
    } catch (e) {
      debugPrint("Error loading partner data for profile: $e");
    }
  }


  @override
  void dispose() {
    // --- ⚠️ MODIFIED: Dispose New Controllers ---
    _nameController.dispose();
    _moodController.dispose();
    _activityController.dispose();
    _thoughtController.dispose();
    super.dispose();
  }

  // --- ⚠️ NEW: Handle picking and uploading a profile picture ---
  Future<void> _pickAndUploadImage() async {
    if (!mounted || _isUploading) return;

    try {
      final XFile? image = await _picker.pickImage(source: ImageSource.gallery, imageQuality: 70, maxWidth: 800);
      if (image == null) return; // User cancelled

      setState(() => _isUploading = true);

      final String? downloadUrl = await _storageService.uploadProfilePicture(image);

      if (downloadUrl != null) {
        // Manually update local state to show new image immediately
        setState(() {
          _userData['photoURL'] = downloadUrl;
        });
        if (mounted) {
          // --- ⚠️ MOUNTED CHECK FIX ---
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Profile picture updated!'), backgroundColor: Colors.green));
        }
      } else {
        throw Exception("Upload returned null URL");
      }

    } catch (e) {
      debugPrint("Error picking/uploading image: $e");
      if (mounted) {
        // --- ⚠️ MOUNTED CHECK FIX ---
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Failed to upload image. Check permissions/storage rules.'), backgroundColor: AppColors.errorRed));
      }
    } finally {
      if (mounted) setState(() => _isUploading = false);
    }
  }

  // Toggles edit mode or saves profile data
  Future<void> _toggleEditSave() async {
    FocusScope.of(context).unfocus(); // Hide keyboard
    if (_isLoading || _isUploading) return; // Prevent actions while loading/uploading

    if (_isEditing) { // --- Save Logic ---
      setState(() => _isLoading = true);
      try {
        // --- ⚠️ MODIFIED: Save New Fields ---
        await _firestoreService.updateUserProfile({
          'displayName': _nameController.text.trim(),
          'myMood': _moodController.text.trim(),
          'myActivity': _activityController.text.trim(),
          'thinkingOfYou': _thoughtController.text.trim(),
        });

        await _loadUserData(); // Reload data to show saved values
        if (mounted) {
          // --- ⚠️ MOUNTED CHECK FIX ---
          ScaffoldMessenger.of(context).showSnackBar( const SnackBar( content: Text('Profile updated!'), backgroundColor: Colors.green), );
        }
      } catch (e) {
        debugPrint("Save Profile Error: $e");
        if (mounted) {
          // --- ⚠️ MOUNTED CHECK FIX ---
          ScaffoldMessenger.of(context).showSnackBar( const SnackBar( content: Text('Failed to update profile. Check Rules/Connection.'), backgroundColor: AppColors.errorRed), );
        }
      } finally {
        if (mounted) setState(() { _isLoading = false; _isEditing = false; }); // Exit loading and edit mode
      }
    } else { // --- Enter Edit Mode ---
      setState(() => _isEditing = true);
    }
  }

  // Handles the Unpair action
  Future<void> _handleUnpair() async {
    if (widget.partnerId == null || !mounted || _isLoading || _isUploading) return;
    final confirmed = await showConfirmationDialog( context, title: 'Unpair Partner?', content: 'Are you sure? This will remove your connection, but you can pair again later.', confirmText: 'Unpair', isDestructive: true, );
    if (confirmed && mounted) {
      try {
        setState(() => _isLoading = true);
        debugPrint("Unpair: Calling unpair()..."); // DEBUG LOG
        await _firestoreService.unpair(widget.partnerId!);
        debugPrint("Unpair successful. Auth stream will handle navigation."); // Debugging

        if(mounted) {
          // --- ⚠️ MOUNTED CHECK FIX ---
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Unpaired successfully.'), backgroundColor: Colors.green));
          // Navigation is handled by PairingCheckerScreen stream
        }
      } catch (e) {
        debugPrint("Unpair Error: $e");
        if (mounted) {
          // --- ⚠️ MOUNTED CHECK FIX ---
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Failed to unpair.'), backgroundColor: AppColors.errorRed));
        }
        if (mounted) setState(() => _isLoading = false); // Reset loading on error
      }
    }
  }

  // Handles the Logout action
  Future<void> _handleLogout() async {
    if (!mounted || _isLoading || _isUploading) return;
    final confirmed = await showConfirmationDialog( context, title: 'Logout?', content: 'Are you sure you want to log out?', confirmText: 'Logout', isDestructive: true, );
    if (confirmed) {
      try {
        setState(() => _isLoading = true);
        debugPrint("Logout: Calling signOut()..."); // DEBUG LOG
        await FirebaseAuthService().signOut();
        debugPrint("Logout successful. Auth stream should handle navigation."); // Debugging

        if (mounted) {
          debugPrint("Logout: Navigating to AuthScreen using rootNavigator...");
          Navigator.of(context, rootNavigator: true).pushAndRemoveUntil(
              MaterialPageRoute(builder: (_) => const AuthScreen(), settings: const RouteSettings(name: '/auth')),
                  (route) => false);
        }
      } catch (e) {
        debugPrint("Logout Error: $e");
        if (mounted) {
          // --- ⚠️ MOUNTED CHECK FIX ---
          ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Failed to log out.'), backgroundColor: AppColors.errorRed));
        }
        if (mounted) setState(() => _isLoading = false);
      }
    }
  }


  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;
    // --- ⚠️ NEW: Use photoURL from state for immediate updates ---
    final String? photoUrl = _userData['photoURL'] as String?;

    return GradientBackground(
      child: ResponsiveCenter(
        child: SingleChildScrollView( // Essential for keyboard and content overflow
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              children: [
                // --- FIX: Edit/Save Button Row ---
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    Padding( padding: const EdgeInsets.only(right: 8.0),
                      child: _isLoading
                          ? const Center(child: SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2, color: AppColors.accentOrange)))
                          : TextButton( onPressed: _toggleEditSave, child: Text(_isEditing ? 'Save' : 'Edit'), ),
                    )
                  ],
                ),

                // --- Profile Header ---
                Column( children: [
                  // --- ⚠️ NEW: Clickable Avatar for Upload ---
                  Stack(
                    alignment: Alignment.bottomRight,
                    children: [
                      CircleAvatar(
                        radius: 50,
                        backgroundColor: AppColors.cardBackground,
                        backgroundImage: (photoUrl != null && photoUrl.isNotEmpty) ? NetworkImage(photoUrl) : null,
                        child: (photoUrl == null || photoUrl.isEmpty) ?  Icon(Icons.person_rounded, size: 50, color: AppColors.textSecondary) : null,
                      ),
                      if (_isEditing) // Show edit button only in edit mode
                        GestureDetector(
                          onTap: _pickAndUploadImage,
                          child: Container(
                            padding: const EdgeInsets.all(6),
                            decoration: BoxDecoration(
                                color: AppColors.accentOrange,
                                shape: BoxShape.circle,
                                border: Border.all(color: AppColors.primaryBackground, width: 2)
                            ),
                            child: _isUploading
                                ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
                                : const Icon(Icons.edit_rounded, size: 16, color: Colors.white),
                          ),
                        ),
                    ],
                  ),
                  const SizedBox(height: 16),
                  _isEditing ? TextField( controller: _nameController, textAlign: TextAlign.center, style: AppTextStyles.headline2, decoration: const InputDecoration( hintText: 'Your Name', isDense: true, border: InputBorder.none, enabledBorder: InputBorder.none, focusedBorder: UnderlineInputBorder( borderSide: BorderSide(color: AppColors.accentOrange), ), ), textInputAction: TextInputAction.next, )
                      : Text( _nameController.text.isNotEmpty ? _nameController.text : 'No Name Set', style: AppTextStyles.headline2, textAlign: TextAlign.center, ),
                  Text( user?.email ?? 'No Email', style: AppTextStyles.bodyText.copyWith(color: AppColors.textSecondary), ),

                  if (_currentStreak > 0)
                    Padding(
                      padding: const EdgeInsets.only(top: 12.0),
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                        decoration: BoxDecoration(
                          color: AppColors.streakFlame.withOpacity(0.15),
                          borderRadius: BorderRadius.circular(20),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(Icons.local_fire_department_rounded, color: AppColors.streakFlame, size: 16),
                            const SizedBox(width: 6),
                            Text( '$_currentStreak Day Streak', style: AppTextStyles.bodyText.copyWith(fontSize: 14, color: AppColors.streakFlame, fontWeight: FontWeight.bold), ),
                          ],
                        ),
                      ),
                    ),

                ],
                ),
                const SizedBox(height: 24),

                // --- ⚠️ NEW: "Connected Since" Card ---
                if (_partnerName != null && _pairedAt != null)
                  Card(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Row(
                        children: [
                          Icon(Icons.favorite_rounded, color: AppColors.accentOrange),
                          SizedBox(width: 16),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text('Connected with $_partnerName', style: AppTextStyles.bodyText.copyWith(fontWeight: FontWeight.w600)),
                                Text('Since ${DateFormat('MMMM d, yyyy').format(_pairedAt!.toDate())}', style: AppTextStyles.bodyText.copyWith(fontSize: 14, color: AppColors.textSecondary)),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),

                const Divider(height: 48),

                // --- ⚠️ MODIFIED: Editable Profile Fields ---
                _buildProfileTextField( _moodController, 'My Current Mood', Icons.sentiment_satisfied_rounded, enabled: _isEditing, keyboardType: TextInputType.text ),
                _buildProfileTextField( _activityController, 'What I\'m Up To', Icons.directions_run_rounded, enabled: _isEditing ),
                _buildProfileTextField( _thoughtController, 'A Thought For You', Icons.chat_bubble_outline_rounded, enabled: _isEditing, isLast: true ),

                const SizedBox(height: 24), const Divider(), const SizedBox(height: 24),

                // --- Action Buttons ---
                if (widget.partnerId != null) // Only show if paired
                  ListTile( leading: const Icon(Icons.link_off_rounded, color: AppColors.errorRed), title: Text('Unpair from Partner', style: AppTextStyles.bodyText.copyWith(color: AppColors.errorRed)), onTap: _handleUnpair, ),

                ListTile( leading: const Icon(Icons.logout_rounded, color: AppColors.errorRed), title: Text('Logout', style: AppTextStyles.bodyText.copyWith(color: AppColors.errorRed)), onTap: _handleLogout, ),
                const SizedBox(height: 100), // --- FIX: Increased bottom padding for nav bar on scroll
              ],
            ),
          ),
        ),
      ),
    );
  }

  // Helper widget for profile text fields
  Widget _buildProfileTextField( TextEditingController controller, String label, IconData icon, { bool enabled = false, TextInputType keyboardType = TextInputType.text, bool isLast = false }) { // Added flag for last field
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: TextField(
        controller: controller,
        enabled: enabled,
        style: AppTextStyles.bodyText,
        keyboardType: keyboardType,
        textInputAction: isLast ? TextInputAction.done : TextInputAction.next, // Use 'done' for the last field
        onSubmitted: isLast ? (_) => _toggleEditSave() : null, // Trigger save on 'done' for last field
        decoration: InputDecoration(
          labelText: label, labelStyle: AppTextStyles.bodyText.copyWith(color: AppColors.textSecondary),
          prefixIcon: Icon(icon, color: AppColors.textSecondary),
          filled: true, fillColor: enabled ? AppColors.cardBackground : AppColors.primaryBackground.withOpacity(0.5), // Make view mode slightly different
          border: enabled ? OutlineInputBorder( borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: AppColors.textSecondary.withOpacity(0.5)) ) : InputBorder.none,
          enabledBorder: enabled ? OutlineInputBorder( borderRadius: BorderRadius.circular(12), borderSide: BorderSide(color: AppColors.textSecondary.withOpacity(0.5)) ) : InputBorder.none,
          focusedBorder: enabled ? OutlineInputBorder( borderRadius: BorderRadius.circular(12), borderSide: const BorderSide(color: AppColors.accentOrange, width: 2) ) : InputBorder.none,
          disabledBorder: InputBorder.none,
        ),
      ),
    );
  }
}
// --- End FIX ---


// --- Reusable Emoji Button Widget ---
class EmojiButton extends StatefulWidget {
  final String emoji; final String label; final VoidCallback onPressed;
  const EmojiButton({ super.key, required this.emoji, required this.label, required this.onPressed, });
  @override State<EmojiButton> createState() => _EmojiButtonState();
}
class _EmojiButtonState extends State<EmojiButton> {
  double _scale = 1.0;
  // FIX: Correct parameter types for GestureDetector callbacks
  void _onTapDown(TapDownDetails d) { setState(() => _scale=0.9); }
  void _onTapUp(TapUpDetails d) { setState(() => _scale=1.0); widget.onPressed(); }
  void _onTapCancel() { setState(() => _scale=1.0); }
  @override Widget build(BuildContext context) {
    return GestureDetector(
      // FIX: Assign correct functions to callbacks
      onTapDown:_onTapDown,
      onTapUp:_onTapUp,
      onTapCancel:_onTapCancel,
      child:AnimatedScale( scale:_scale, duration:const Duration(milliseconds:100),
        child:Column( mainAxisSize: MainAxisSize.min, children: [
          Container( width: 50, height: 50, decoration:BoxDecoration( color: AppColors.cardBackground, shape:BoxShape.circle, boxShadow:[BoxShadow(color:Colors.black.withAlpha(51), blurRadius:5, spreadRadius:2)]), child:Center(child:Text(widget.emoji, style:const TextStyle(fontSize: 24))) ),
          const SizedBox(height: 8),
          Text(widget.label, style:AppTextStyles.smallButtonText.copyWith(color:AppColors.textSecondary), overflow: TextOverflow.ellipsis,),
        ],
        ),
      ),
    );
  }
}